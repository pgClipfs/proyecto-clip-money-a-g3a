(window.webpackJsonp = window.webpackJsonp || []).push([[1], { 0: function (t, e, n) { t.exports = n("zUnb") }, zUnb: function (t, e, n) { "use strict"; function r(t) { return "function" == typeof t } n.r(e); let s = !1; const i = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = t }, get useDeprecatedSynchronousErrorHandling() { return s } }; function o(t) { setTimeout(() => { throw t }, 0) } const a = { closed: !0, next(t) { }, error(t) { if (i.useDeprecatedSynchronousErrorHandling) throw t; o(t) }, complete() { } }, l = (() => Array.isArray || (t => t && "number" == typeof t.length))(); function u(t) { return null !== t && "object" == typeof t } const c = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let h = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: n, _ctorUnsubscribe: s, _unsubscribe: i, _subscriptions: o } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof t) n.remove(this); else if (null !== n) for (let t = 0; t < n.length; ++t)n[t].remove(this); if (r(i)) { s && (this._unsubscribe = void 0); try { i.call(this) } catch (a) { e = a instanceof c ? d(a.errors) : [a] } } if (l(o)) { let t = -1, n = o.length; for (; ++t < n;) { const n = o[t]; if (u(n)) try { n.unsubscribe() } catch (a) { e = e || [], a instanceof c ? e = e.concat(d(a.errors)) : e.push(a) } } } if (e) throw new c(e) } add(e) { let n = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: r } = n; if (null === r) n._parentOrParents = this; else if (r instanceof t) { if (r === this) return n; n._parentOrParents = [r, this] } else { if (-1 !== r.indexOf(this)) return n; r.push(this) } const s = this._subscriptions; return null === s ? this._subscriptions = [n] : s.push(n), n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } } return t.EMPTY = function (t) { return t.closed = !0, t }(new t), t })(); function d(t) { return t.reduce((t, e) => t.concat(e instanceof c ? e.errors : e), []) } const p = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())(); class f extends h { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = a; break; case 1: if (!t) { this.destination = a; break } if ("object" == typeof t) { t instanceof f ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new g(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new g(this, t, e, n) } } [p]() { return this } static create(t, e, n) { const r = new f(t, e, n); return r.syncErrorThrowable = !1, r } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class g extends f { constructor(t, e, n, s) { let i; super(), this._parentSubscriber = t; let o = this; r(e) ? i = e : e && (i = e.next, n = e.error, s = e.complete, e !== a && (o = Object.create(e), r(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = i, this._error = n, this._complete = s } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; i.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = i; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : o(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; o(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); i.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), i.useDeprecatedSynchronousErrorHandling) throw n; o(n) } } __tryOrSetError(t, e, n) { if (!i.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (r) { return i.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0, !0) : (o(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const m = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")(); function y(t) { return t } let _ = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: r } = this, s = function (t, e, n) { if (t) { if (t instanceof f) return t; if (t[p]) return t[p]() } return t || e || n ? new f(t, e, n) : new f(a) }(t, e, n); if (s.add(r ? r.call(s, this.source) : this.source || i.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), i.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { i.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: r } = t; if (e || r) return !1; t = n && n instanceof f ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = v(e))((e, n) => { let r; r = this.subscribe(e => { try { t(e) } catch (s) { n(s), r && r.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [m]() { return this } pipe(...t) { return 0 === t.length ? this : (0 === (e = t).length ? y : 1 === e.length ? e[0] : function (t) { return e.reduce((t, e) => e(t), t) })(this); var e } toPromise(t) { return new (t = v(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function v(t) { if (t || (t = i.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } const w = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })(); class b extends h { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } class C extends f { constructor(t) { super(t), this.destination = t } } let S = (() => { class t extends _ { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [p]() { return new C(this) } lift(t) { const e = new x(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new w; if (!this.isStopped) { const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].next(t) } } error(t) { if (this.closed) throw new w; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new w; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let r = 0; r < e; r++)n[r].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new w; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new w; return this.hasError ? (t.error(this.thrownError), h.EMPTY) : this.isStopped ? (t.complete(), h.EMPTY) : (this.observers.push(t), new b(this, t)) } asObservable() { const t = new _; return t.source = this, t } } return t.create = (t, e) => new x(t, e), t })(); class x extends S { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : h.EMPTY } } function E(t) { return t && "function" == typeof t.schedule } function T(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new A(t, e)) } } class A { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new k(t, this.project, this.thisArg)) } } class k extends f { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const O = t => e => { for (let n = 0, r = t.length; n < r && !e.closed; n++)e.next(t[n]); e.complete() }; function R() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const I = R(), P = t => t && "number" == typeof t.length && "function" != typeof t; function V(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const j = t => { if (t && "function" == typeof t[m]) return r = t, t => { const e = r[m](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (P(t)) return O(t); if (V(t)) return n = t, t => (n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, o), t); if (t && "function" == typeof t[I]) return e = t, t => { const n = e[I](); for (; ;) { let e; try { e = n.next() } catch (r) { return t.error(r), t } if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof n.return && t.add(() => { n.return && n.return() }), t }; { const e = u(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var e, n, r }; function N(t, e) { return new _(n => { const r = new h; let s = 0; return r.add(e.schedule((function () { s !== t.length ? (n.next(t[s++]), n.closed || r.add(this.schedule())) : n.complete() }))), r }) } function D(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[m] }(t)) return function (t, e) { return new _(n => { const r = new h; return r.add(e.schedule(() => { const s = t[m](); r.add(s.subscribe({ next(t) { r.add(e.schedule(() => n.next(t))) }, error(t) { r.add(e.schedule(() => n.error(t))) }, complete() { r.add(e.schedule(() => n.complete())) } })) })), r }) }(t, e); if (V(t)) return function (t, e) { return new _(n => { const r = new h; return r.add(e.schedule(() => t.then(t => { r.add(e.schedule(() => { n.next(t), r.add(e.schedule(() => n.complete())) })) }, t => { r.add(e.schedule(() => n.error(t))) }))), r }) }(t, e); if (P(t)) return N(t, e); if (function (t) { return t && "function" == typeof t[I] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new _(n => { const r = new h; let s; return r.add(() => { s && "function" == typeof s.return && s.return() }), r.add(e.schedule(() => { s = t[I](), r.add(e.schedule((function () { if (n.closed) return; let t, e; try { const n = s.next(); t = n.value, e = n.done } catch (r) { return void n.error(r) } e ? n.complete() : (n.next(t), this.schedule()) }))) })), r }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof _ ? t : new _(j(t)) } class U extends f { constructor(t) { super(), this.parent = t } _next(t) { this.parent.notifyNext(t) } _error(t) { this.parent.notifyError(t), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class M extends f { notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.destination.complete() } } function F(t, e) { if (!e.closed) return t instanceof _ ? t.subscribe(e) : j(t)(e) } function L(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? r => r.pipe(L((n, r) => D(t(n, r)).pipe(T((t, s) => e(n, t, r, s))), n)) : ("number" == typeof e && (n = e), e => e.lift(new H(t, n))) } class H { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new $(t, this.project, this.concurrent)) } } class $ extends M { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this.active++ , this._innerSub(e) } _innerSub(t) { const e = new U(this), n = this.destination; n.add(e); const r = F(t, e); r !== e && n.add(r) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyComplete() { const t = this.buffer; this.active-- , t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function z(t = Number.POSITIVE_INFINITY) { return L(y, t) } function B(t, e) { return e ? N(t, e) : new _(O(t)) } function q() { return function (t) { return t.lift(new W(t)) } } class W { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const r = new Z(t, n), s = e.subscribe(r); return r.closed || (r.connection = n.connect()), s } } class Z extends f { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, r = t._connection; this.connection = null, !r || n && r !== n || r.unsubscribe() } } class G extends _ { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new h, t.add(this.source.subscribe(new K(this.getSubject(), this))), t.closed && (this._connection = null, t = h.EMPTY)), t } refCount() { return q()(this) } } const Q = (() => { const t = G.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class K extends C { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function J() { return new S } function Y(t) { return { toString: t }.toString() } const X = "__parameters__"; function tt(t, e, n) { return Y(() => { const r = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function s(...t) { if (this instanceof s) return r.apply(this, t), this; const e = new s(...t); return n.annotation = e, n; function n(t, n, r) { const s = t.hasOwnProperty(X) ? t[X] : Object.defineProperty(t, X, { value: [] })[X]; for (; s.length <= r;)s.push(null); return (s[r] = s[r] || []).push(e), t } } return n && (s.prototype = Object.create(n.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s }) } const et = tt("Inject", t => ({ token: t })), nt = tt("Optional"), rt = tt("Self"), st = tt("SkipSelf"); var it = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); function ot(t) { for (let e in t) if (t[e] === ot) return e; throw Error("Could not find renamed property on target object.") } function at(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function lt(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function ut(t) { return { factory: t.factory, providers: t.providers || [], imports: t.imports || [] } } function ct(t) { return ht(t, t[pt]) || ht(t, t[mt]) } function ht(t, e) { return e && e.token === t ? e : null } function dt(t) { return t && (t.hasOwnProperty(ft) || t.hasOwnProperty(yt)) ? t[ft] : null } const pt = ot({ "\u0275prov": ot }), ft = ot({ "\u0275inj": ot }), gt = ot({ "\u0275provFallback": ot }), mt = ot({ ngInjectableDef: ot }), yt = ot({ ngInjectorDef: ot }); function _t(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(_t).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return "" + t.overriddenName; if (t.name) return "" + t.name; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function vt(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const wt = ot({ __forward_ref__: ot }); function bt(t) { return t.__forward_ref__ = bt, t.toString = function () { return _t(this()) }, t } function Ct(t) { return St(t) ? t() : t } function St(t) { return "function" == typeof t && t.hasOwnProperty(wt) && t.__forward_ref__ === bt } const xt = "undefined" != typeof globalThis && globalThis, Et = "undefined" != typeof window && window, Tt = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, At = "undefined" != typeof global && global, kt = xt || At || Et || Tt, Ot = ot({ "\u0275cmp": ot }), Rt = ot({ "\u0275dir": ot }), It = ot({ "\u0275pipe": ot }), Pt = ot({ "\u0275mod": ot }), Vt = ot({ "\u0275loc": ot }), jt = ot({ "\u0275fac": ot }), Nt = ot({ __NG_ELEMENT_ID__: ot }); class Dt { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = lt({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return "InjectionToken " + this._desc } } const Ut = new Dt("INJECTOR", -1), Mt = {}, Ft = /\n/gm, Lt = "__source", Ht = ot({ provide: String, useValue: ot }); let $t, zt = void 0; function Bt(t) { const e = zt; return zt = t, e } function qt(t) { const e = $t; return $t = t, e } function Wt(t, e = it.Default) { if (void 0 === zt) throw new Error("inject() must be called from an injection context"); return null === zt ? Gt(t, void 0, e) : zt.get(t, e & it.Optional ? null : void 0, e) } function Zt(t, e = it.Default) { return ($t || Wt)(Ct(t), e) } function Gt(t, e, n) { const r = ct(t); if (r && "root" == r.providedIn) return void 0 === r.value ? r.value = r.factory() : r.value; if (n & it.Optional) return null; if (void 0 !== e) return e; throw new Error(`Injector: NOT_FOUND [${_t(t)}]`) } function Qt(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = Ct(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new Error("Arguments array must have arguments."); let t = void 0, n = it.Default; for (let e = 0; e < r.length; e++) { const s = r[e]; s instanceof nt || "Optional" === s.ngMetadataName || s === nt ? n |= it.Optional : s instanceof st || "SkipSelf" === s.ngMetadataName || s === st ? n |= it.SkipSelf : s instanceof rt || "Self" === s.ngMetadataName || s === rt ? n |= it.Self : t = s instanceof et || s === et ? s.token : s } e.push(Zt(t, n)) } else e.push(Zt(r)) } return e } class Kt { get(t, e = Mt) { if (e === Mt) { const e = new Error(`NullInjectorError: No provider for ${_t(t)}!`); throw e.name = "NullInjectorError", e } return e } } class Jt { } class Yt { } function Xt(t, e) { t.forEach(t => Array.isArray(t) ? Xt(t, e) : e(t)) } function te(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function ee(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function ne(t, e) { const n = []; for (let r = 0; r < t; r++)n.push(e); return n } function re(t, e, n) { let r = ie(t, e); return r >= 0 ? t[1 | r] = n : (r = ~r, function (t, e, n, r) { let s = t.length; if (s == e) t.push(n, r); else if (1 === s) t.push(r, t[0]), t[0] = n; else { for (s-- , t.push(t[s - 1], t[s]); s > e;)t[s] = t[s - 2], s--; t[e] = n, t[e + 1] = r } }(t, r, e, n)), r } function se(t, e) { const n = ie(t, e); if (n >= 0) return t[1 | n] } function ie(t, e) { return function (t, e, n) { let r = 0, s = t.length >> 1; for (; s !== r;) { const n = r + (s - r >> 1), i = t[n << 1]; if (e === i) return n << 1; i > e ? s = n : r = n + 1 } return ~(s << 1) }(t, e) } var oe = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }({}), ae = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.Native = 1] = "Native", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }({}); const le = {}, ue = []; let ce = 0; function he(t) { return Y(() => { const e = {}, n = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === oe.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || ue, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || ae.Emulated, id: "c", styles: t.styles || ue, _: null, setInput: null, schemas: t.schemas || null, tView: null }, r = t.directives, s = t.features, i = t.pipes; return n.id += ce++ , n.inputs = me(t.inputs, e), n.outputs = me(t.outputs), s && s.forEach(t => t(n)), n.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(de) : null, n.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(pe) : null, n }) } function de(t) { return _e(t) || function (t) { return t[Rt] || null }(t) } function pe(t) { return function (t) { return t[It] || null }(t) } const fe = {}; function ge(t) { const e = { type: t.type, bootstrap: t.bootstrap || ue, declarations: t.declarations || ue, imports: t.imports || ue, exports: t.exports || ue, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && Y(() => { fe[t.id] = t.type }), e } function me(t, e) { if (null == t) return le; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let s = t[r], i = s; Array.isArray(s) && (i = s[1], s = s[0]), n[s] = r, e && (e[s] = i) } return n } const ye = he; function _e(t) { return t[Ot] || null } function ve(t, e) { return t.hasOwnProperty(jt) ? t[jt] : null } function we(t, e) { const n = t[Pt] || null; if (!n && !0 === e) throw new Error(`Type ${_t(t)} does not have '\u0275mod' property.`); return n } const be = 20, Ce = 10; function Se(t) { return Array.isArray(t) && "object" == typeof t[1] } function xe(t) { return Array.isArray(t) && !0 === t[1] } function Ee(t) { return 0 != (8 & t.flags) } function Te(t) { return 2 == (2 & t.flags) } function Ae(t) { return 1 == (1 & t.flags) } function ke(t) { return null !== t.template } function Oe(t) { return 0 != (512 & t[2]) } function Re(t) { return "string" == typeof t ? t : null == t ? "" : "" + t } function Ie(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : Re(t) } const Pe = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(kt))(); function Ve(t) { return t instanceof Function ? t() : t } function je(t, e) { const n = e ? " in " + e : ""; throw new Error(`No provider for ${Ie(t)} found${n}`) } class Ne { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } function De() { return Ue } function Ue(t) { return t.type.prototype.ngOnChanges && (t.setInput = Fe), Me } function Me() { const t = Le(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === le) t.previous = e; else for (let t in e) n[t] = e[t]; t.current = null, this.ngOnChanges(e) } } function Fe(t, e, n, r) { const s = Le(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: le, current: null }), i = s.current || (s.current = {}), o = s.previous, a = this.declaredInputs[n], l = o[a]; i[a] = new Ne(l && l.currentValue, e, o === le), t[r] = e } function Le(t) { return t.__ngSimpleChanges__ || null } De.ngInherit = !0; let He = void 0; function $e(t) { return !!t.listen } const ze = { createRenderer: (t, e) => void 0 !== He ? He : "undefined" != typeof document ? document : void 0 }; function Be(t) { for (; Array.isArray(t);)t = t[0]; return t } function qe(t, e) { return Be(e[t + be]) } function We(t, e) { return Be(e[t.index]) } function Ze(t, e) { return t.data[e + be] } function Ge(t, e) { const n = e[t]; return Se(n) ? n : n[0] } function Qe(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function Ke(t) { return 4 == (4 & t[2]) } function Je(t) { return 128 == (128 & t[2]) } function Ye(t, e) { return null === t || null == e ? null : t[e] } function Xe(t) { t[18] = 0 } function tn(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const en = { lFrame: bn(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function nn() { return en.bindingsEnabled } function rn() { return en.lFrame.lView } function sn() { return en.lFrame.tView } function on() { return en.lFrame.currentTNode } function an(t, e) { en.lFrame.currentTNode = t, en.lFrame.isParent = e } function ln() { return en.lFrame.isParent } function un() { en.lFrame.isParent = !1 } function cn() { return en.isInCheckNoChangesMode } function hn(t) { en.isInCheckNoChangesMode = t } function dn() { return en.lFrame.bindingIndex++ } function pn(t) { const e = en.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n } function fn(t, e) { const n = en.lFrame; n.bindingIndex = n.bindingRootIndex = t, gn(e) } function gn(t) { en.lFrame.currentDirectiveIndex = t } function mn() { return en.lFrame.currentQueryIndex } function yn(t) { en.lFrame.currentQueryIndex = t } function _n(t, e) { const n = wn(); en.lFrame = n, n.currentTNode = e, n.lView = t } function vn(t) { const e = wn(), n = t[1]; en.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex } function wn() { const t = en.lFrame, e = null === t ? null : t.child; return null === e ? bn(t) : e } function bn(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: 0, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null }; return null !== t && (t.child = e), e } function Cn() { const t = en.lFrame; return en.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const Sn = Cn; function xn() { const t = Cn(); t.isParent = !0, t.tView = null, t.selectedIndex = 0, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function En() { return en.lFrame.selectedIndex } function Tn(t) { en.lFrame.selectedIndex = t } function An() { const t = en.lFrame; return Ze(t.tView, t.selectedIndex) } function kn(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const e = t.data[n].type.prototype, { ngAfterContentInit: r, ngAfterContentChecked: s, ngAfterViewInit: i, ngAfterViewChecked: o, ngOnDestroy: a } = e; r && (t.contentHooks || (t.contentHooks = [])).push(-n, r), s && ((t.contentHooks || (t.contentHooks = [])).push(n, s), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, s)), i && (t.viewHooks || (t.viewHooks = [])).push(-n, i), o && ((t.viewHooks || (t.viewHooks = [])).push(n, o), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)), null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a) } } function On(t, e, n) { Pn(t, e, 3, n) } function Rn(t, e, n, r) { (3 & t[2]) === n && Pn(t, e, n, r) } function In(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function Pn(t, e, n, r) { const s = null != r ? r : -1; let i = 0; for (let o = void 0 !== r ? 65535 & t[18] : 0; o < e.length; o++)if ("number" == typeof e[o + 1]) { if (i = e[o], null != r && i >= r) break } else e[o] < 0 && (t[18] += 65536), (i < s || -1 == s) && (Vn(t, n, e, o), t[18] = (4294901760 & t[18]) + o + 2), o++ } function Vn(t, e, n, r) { const s = n[r] < 0, i = n[r + 1], o = t[s ? -n[r] : n[r]]; s ? t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e && (t[2] += 2048, i.call(o)) : i.call(o) } const jn = -1; class Nn { constructor(t, e, n) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = n } } function Dn(t, e, n) { const r = $e(t); let s = 0; for (; s < n.length;) { const i = n[s]; if ("number" == typeof i) { if (0 !== i) break; s++; const o = n[s++], a = n[s++], l = n[s++]; r ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = i, a = n[++s]; Mn(o) ? r && t.setProperty(e, o, a) : r ? t.setAttribute(e, o, a) : e.setAttribute(o, a), s++ } } return s } function Un(t) { return 3 === t || 4 === t || 6 === t } function Mn(t) { return 64 === t.charCodeAt(0) } function Fn(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const s = e[r]; "number" == typeof s ? n = s : 0 === n || Ln(t, n, s, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function Ln(t, e, n, r, s) { let i = 0, o = t.length; if (-1 === e) o = -1; else for (; i < t.length;) { const n = t[i++]; if ("number" == typeof n) { if (n === e) { o = -1; break } if (n > e) { o = i - 1; break } } } for (; i < t.length;) { const e = t[i]; if ("number" == typeof e) break; if (e === n) { if (null === r) return void (null !== s && (t[i + 1] = s)); if (r === t[i + 1]) return void (t[i + 2] = s) } i++ , null !== r && i++ , null !== s && i++ } -1 !== o && (t.splice(o, 0, e), i = o + 1), t.splice(i++, 0, n), null !== r && t.splice(i++, 0, r), null !== s && t.splice(i++, 0, s) } function Hn(t) { return t !== jn } function $n(t) { return 32767 & t } function zn(t, e) { let n = t >> 16, r = e; for (; n > 0;)r = r[15], n--; return r } let Bn = !0; function qn(t) { const e = Bn; return Bn = t, e } let Wn = 0; function Zn(t, e) { const n = Qn(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, Gn(r.data, t), Gn(e, null), Gn(r.blueprint, null)); const s = Kn(t, e), i = t.injectorIndex; if (Hn(s)) { const t = $n(s), n = zn(s, e), r = n[1].data; for (let s = 0; s < 8; s++)e[i + s] = n[t + s] | r[t + s] } return e[i + 8] = s, i } function Gn(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Qn(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function Kn(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, r = null, s = e; for (; null !== s;) { const t = s[1], e = t.type; if (r = 2 === e ? t.declTNode : 1 === e ? s[6] : null, null === r) return jn; if (n++ , s = s[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return jn } function Jn(t, e, n) { !function (t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Nt) && (r = n[Nt]), null == r && (r = n[Nt] = Wn++); const s = 255 & r, i = 1 << s, o = 64 & s, a = 32 & s, l = e.data; 128 & s ? o ? a ? l[t + 7] |= i : l[t + 6] |= i : a ? l[t + 5] |= i : l[t + 4] |= i : o ? a ? l[t + 3] |= i : l[t + 2] |= i : a ? l[t + 1] |= i : l[t] |= i }(t, e, n) } function Yn(t, e, n, r = it.Default, s) { if (null !== t) { const s = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(Nt) ? t[Nt] : void 0; return "number" == typeof e && e > 0 ? 255 & e : e }(n); if ("function" == typeof s) { _n(e, t); try { const t = s(); if (null != t || r & it.Optional) return t; je(n) } finally { Sn() } } else if ("number" == typeof s) { if (-1 === s) return new ir(t, e); let i = null, o = Qn(t, e), a = jn, l = r & it.Host ? e[16][6] : null; for ((-1 === o || r & it.SkipSelf) && (a = -1 === o ? Kn(t, e) : e[o + 8], a !== jn && sr(r, !1) ? (i = e[1], o = $n(a), e = zn(a, e)) : o = -1); -1 !== o;) { const t = e[1]; if (rr(s, o, t.data)) { const t = tr(o, e, n, i, r, l); if (t !== Xn) return t } a = e[o + 8], a !== jn && sr(r, e[1].data[o + 8] === l) && rr(s, o, e) ? (i = t, o = $n(a), e = zn(a, e)) : o = -1 } } } if (r & it.Optional && void 0 === s && (s = null), 0 == (r & (it.Self | it.Host))) { const t = e[9], i = qt(void 0); try { return t ? t.get(n, s, r & it.Optional) : Gt(n, s, r & it.Optional) } finally { qt(i) } } if (r & it.Optional) return s; je(n, "NodeInjector") } const Xn = {}; function tr(t, e, n, r, s, i) { const o = e[1], a = o.data[t + 8], l = er(a, o, n, null == r ? Te(a) && Bn : r != o && 2 === a.type, s & it.Host && i === a); return null !== l ? nr(e, o, l, a) : Xn } function er(t, e, n, r, s) { const i = t.providerIndexes, o = e.data, a = 1048575 & i, l = t.directiveStart, u = i >> 20, c = s ? a + u : t.directiveEnd; for (let h = r ? a : a + u; h < c; h++) { const t = o[h]; if (h < l && n === t || h >= l && t.type === n) return h } if (s) { const t = o[l]; if (t && ke(t) && t.type === n) return l } return null } function nr(t, e, n, r) { let s = t[n]; const i = e.data; if (s instanceof Nn) { const o = s; o.resolving && function (t, e) { throw new Error("Circular dependency in DI detected for " + t) }(Ie(i[n])); const a = qn(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? qt(o.injectImpl) : null; _n(t, r); try { s = t[n] = o.factory(void 0, i, t, r), e.firstCreatePass && n >= r.directiveStart && function (t, e, n) { const { ngOnChanges: r, ngOnInit: s, ngDoCheck: i } = e.type.prototype; if (r) { const r = Ue(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, r), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, r) } s && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, s), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, i)) }(n, i[n], e) } finally { null !== l && qt(l), qn(a), o.resolving = !1, Sn() } } return s } function rr(t, e, n) { const r = 64 & t, s = 32 & t; let i; return i = 128 & t ? r ? s ? n[e + 7] : n[e + 6] : s ? n[e + 5] : n[e + 4] : r ? s ? n[e + 3] : n[e + 2] : s ? n[e + 1] : n[e], !!(i & 1 << t) } function sr(t, e) { return !(t & it.Self || t & it.Host && e) } class ir { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return Yn(this._tNode, this._lView, t, void 0, e) } } function or(t) { const e = t; if (St(t)) return () => { const t = or(Ct(e)); return t ? t() : null }; let n = ve(e); if (null === n) { const t = dt(e); n = t && t.factory } return n || null } function ar(t) { return Y(() => { const e = t.prototype.constructor, n = e[jt] || or(e), r = Object.prototype; let s = Object.getPrototypeOf(t.prototype).constructor; for (; s && s !== r;) { const t = s[jt] || or(s); if (t && t !== n) return t; s = Object.getPrototypeOf(s) } return t => new t }) } function lr(t) { return t.ngDebugContext } function ur(t) { return t.ngOriginalError } function cr(t, ...e) { t.error(...e) } class hr { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), r = function (t) { return t.ngErrorLogger || cr }(t); r(this._console, "ERROR", t), e && r(this._console, "ORIGINAL ERROR", e), n && r(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? lr(t) ? lr(t) : this._findContext(ur(t)) : null } _findOriginalError(t) { let e = ur(t); for (; e && ur(e);)e = ur(e); return e } } class dr { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity + " (see http://g.co/ng/security#xss)" } } function pr(t) { return t instanceof dr ? t.changingThisBreaksApplicationSecurity : t } let fr = !0, gr = !1; function mr() { return gr = !0, fr } const yr = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, _r = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; var vr = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }({}); function wr(t) { const e = function () { const t = rn(); return t && t[12] }(); return e ? e.sanitize(vr.URL, t) || "" : function (t, e) { const n = function (t) { return t instanceof dr && t.getTypeName() || null }(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see http://g.co/ng/security#xss)`) } return n === e }(t, "URL") ? pr(t) : (n = Re(t), (n = String(n)).match(yr) || n.match(_r) ? n : (mr() && console.warn(`WARNING: sanitizing unsafe URL value ${n} (see http://g.co/ng/security#xss)`), "unsafe:" + n)); var n } function br(t, e) { t.__ngContext__ = e } function Cr(t, e, n) { let r = t.length; for (; ;) { const s = t.indexOf(e, n); if (-1 === s) return s; if (0 === s || t.charCodeAt(s - 1) <= 32) { const n = e.length; if (s + n === r || t.charCodeAt(s + n) <= 32) return s } n = s + 1 } } const Sr = "ng-template"; function xr(t, e, n) { let r = 0; for (; r < t.length;) { let s = t[r++]; if (n && "class" === s) { if (s = t[r], -1 !== Cr(s.toLowerCase(), e, 0)) return !0 } else if (1 === s) { for (; r < t.length && "string" == typeof (s = t[r++]);)if (s.toLowerCase() === e) return !0; return !1 } } return !1 } function Er(t) { return 0 === t.type && t.tagName !== Sr } function Tr(t, e, n) { return e === (0 !== t.type || n ? t.tagName : Sr) } function Ar(t, e, n) { let r = 4; const s = t.attrs || [], i = function (t) { for (let e = 0; e < t.length; e++)if (Un(t[e])) return e; return t.length }(s); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !Tr(t, l, n) || "" === l && 1 === e.length) { if (kr(r)) return !1; o = !0 } } else { const u = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!xr(t.attrs, u, n)) { if (kr(r)) return !1; o = !0 } continue } const c = Or(8 & r ? "class" : l, s, Er(t), n); if (-1 === c) { if (kr(r)) return !1; o = !0; continue } if ("" !== u) { let t; t = c > i ? "" : s[c + 1].toLowerCase(); const e = 8 & r ? t : null; if (e && -1 !== Cr(e, u, 0) || 2 & r && u !== t) { if (kr(r)) return !1; o = !0 } } } } else { if (!o && !kr(r) && !kr(l)) return !1; if (o && kr(l)) continue; o = !1, r = l | 1 & r } } return kr(r) || o } function kr(t) { return 0 == (1 & t) } function Or(t, e, n, r) { if (null === e) return -1; let s = 0; if (r || !n) { let n = !1; for (; s < e.length;) { const r = e[s]; if (r === t) return s; if (3 === r || 6 === r) n = !0; else { if (1 === r || 2 === r) { let t = e[++s]; for (; "string" == typeof t;)t = e[++s]; continue } if (4 === r) break; if (0 === r) { s += 4; continue } } s += n ? 1 : 2 } return -1 } return function (t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function Rr(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (Ar(t, e[r], n)) return !0; return !1 } function Ir(t, e) { return t ? ":not(" + e.trim() + ")" : e } function Pr(t) { let e = t[0], n = 1, r = 2, s = "", i = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & r) { const e = t[++n]; s += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & r ? s += "." + o : 4 & r && (s += " " + o); else "" === s || kr(o) || (e += Ir(i, s), s = ""), r = o, i = i || !kr(r); n++ } return "" !== s && (e += Ir(i, s)), e } const Vr = {}; function jr(t) { const e = t[3]; return xe(e) ? e[3] : e } function Nr(t) { return Ur(t[13]) } function Dr(t) { return Ur(t[4]) } function Ur(t) { for (; null !== t && !xe(t);)t = t[4]; return t } function Mr(t) { Fr(sn(), rn(), En() + t, cn()) } function Fr(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const r = t.preOrderCheckHooks; null !== r && On(e, r, n) } else { const r = t.preOrderHooks; null !== r && Rn(e, r, 0, n) } Tn(n) } function Lr(t, e) { return t << 17 | e << 2 } function Hr(t) { return t >> 17 & 32767 } function $r(t) { return 2 | t } function zr(t) { return (131068 & t) >> 2 } function Br(t, e) { return -131069 & t | e << 2 } function qr(t) { return 1 | t } function Wr(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const s = n[r], i = n[r + 1]; if (-1 !== i) { const n = t.data[i]; yn(s), n.contentQueries(2, e[i], i) } } } function Zr(t, e, n) { return $e(e) ? e.createElement(t, n) : null === n ? e.createElement(t) : e.createElementNS(n, t) } function Gr(t, e, n, r, s, i, o, a, l, u) { const c = e.blueprint.slice(); return c[0] = s, c[2] = 140 | r, Xe(c), c[3] = c[15] = t, c[8] = n, c[10] = o || t && t[10], c[11] = a || t && t[11], c[12] = l || t && t[12] || null, c[9] = u || t && t[9] || null, c[6] = i, c[16] = 2 == e.type ? t[16] : c, c } function Qr(t, e, n, r, s) { const i = e + be, o = t.data[i] || function (t, e, n, r, s) { const i = on(), o = ln(), a = t.data[e] = function (t, e, n, r, s, i) { return { type: n, index: r, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, tagName: s, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? i : i && i.parent, n, e, r, s); return null === t.firstChild && (t.firstChild = a), null !== i && (o && null == i.child && null !== a.parent ? i.child = a : o || (i.next = a)), a }(t, i, n, r, s); return an(o, !0), o } function Kr(t, e, n) { vn(e); try { const r = t.viewQuery; null !== r && Ts(1, r, n); const s = t.template; null !== s && Xr(t, e, s, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Wr(t, e), t.staticViewQueries && Ts(2, t.viewQuery, n); const i = t.components; null !== i && function (t, e) { for (let n = 0; n < e.length; n++)bs(t, e[n]) }(e, i) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), r } finally { e[2] &= -5, xn() } } function Jr(t, e, n, r) { const s = e[2]; if (256 == (256 & s)) return; vn(e); const i = cn(); try { Xe(e), en.lFrame.bindingIndex = t.bindingStartIndex, null !== n && Xr(t, e, n, 2, r); const o = 3 == (3 & s); if (!i) if (o) { const n = t.preOrderCheckHooks; null !== n && On(e, n, null) } else { const n = t.preOrderHooks; null !== n && Rn(e, n, 0, null), In(e, 0) } if (function (t) { for (let e = Nr(t); null !== e; e = Dr(e)) { if (!e[2]) continue; const t = e[9]; for (let e = 0; e < t.length; e++) { const n = t[e], r = n[3]; 0 == (1024 & n[2]) && tn(r, 1), n[2] |= 1024 } } }(e), function (t) { for (let e = Nr(t); null !== e; e = Dr(e))for (let t = Ce; t < e.length; t++) { const n = e[t], r = n[1]; Je(n) && Jr(r, n, r.template, n[8]) } }(e), null !== t.contentQueries && Wr(t, e), !i) if (o) { const n = t.contentCheckHooks; null !== n && On(e, n) } else { const n = t.contentHooks; null !== n && Rn(e, n, 1), In(e, 1) } !function (t, e) { try { const n = t.expandoInstructions; if (null !== n) { let r = t.expandoStartIndex, s = -1, i = -1; for (let t = 0; t < n.length; t++) { const o = n[t]; "number" == typeof o ? o <= 0 ? (i = 0 - o, Tn(i), r += 9 + n[++t], s = r) : r += o : (null !== o && (fn(r, s), o(2, e[s])), s++) } } } finally { Tn(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let n = 0; n < e.length; n++)ws(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && Ts(2, l, r), !i) if (o) { const n = t.viewCheckHooks; null !== n && On(e, n) } else { const n = t.viewHooks; null !== n && Rn(e, n, 2), In(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), i || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, tn(e[3], -1)) } finally { xn() } } function Yr(t, e, n, r) { const s = e[10], i = !cn(), o = Ke(e); try { i && !o && s.begin && s.begin(), o && Kr(t, e, r), Jr(t, e, n, r) } finally { i && !o && s.end && s.end() } } function Xr(t, e, n, r, s) { const i = En(); try { Tn(-1), 2 & r && e.length > be && Fr(t, e, 0, cn()), n(r, s) } finally { Tn(i) } } function ts(t, e, n) { nn() && (function (t, e, n, r) { const s = n.directiveStart, i = n.directiveEnd; t.firstCreatePass || Zn(n, e), br(r, e); const o = n.initialInputs; for (let a = s; a < i; a++) { const r = t.data[a], i = ke(r); i && ms(e, n, r); const l = nr(e, t, a, n); br(l, e), null !== o && ys(0, a - s, l, r, 0, o), i && (Ge(n.index, e)[8] = l) } }(t, e, n, We(n, e)), 128 == (128 & n.flags) && function (t, e, n) { const r = n.directiveStart, s = n.directiveEnd, i = t.expandoInstructions, o = t.firstCreatePass, a = n.index - be, l = en.lFrame.currentDirectiveIndex; try { Tn(a); for (let n = r; n < s; n++) { const r = t.data[n], s = e[n]; gn(n), null !== r.hostBindings || 0 !== r.hostVars || null !== r.hostAttrs ? cs(r, s) : o && i.push(null) } } finally { Tn(-1), gn(l) } }(t, e, n)) } function es(t, e, n = We) { const r = e.localNames; if (null !== r) { let s = e.index + 1; for (let i = 0; i < r.length; i += 2) { const o = r[i + 1], a = -1 === o ? n(e, t) : t[o]; t[s++] = a } } } function ns(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = rs(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function rs(t, e, n, r, s, i, o, a, l, u) { const c = be + r, h = c + s, d = function (t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : Vr); return n }(c, h), p = "function" == typeof u ? u() : u; return d[1] = { type: t, blueprint: d, template: n, queries: null, viewQuery: a, declTNode: e, data: d.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: h, expandoInstructions: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1 } } function ss(t, e, n, r) { const s = ks(e); s.push(n), t.firstCreatePass && function (t) { return t.cleanup || (t.cleanup = []) }(t).push(r, s.length - 1) } function is(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const s = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, s) : n[r] = [e, s] } return n } function os(t, e, n, r, s, i, o, a) { const l = We(e, n); let u, c = e.inputs; var h; !a && null != c && (u = c[r]) ? (Rs(t, n, u, r, s), Te(e) && function (t, e) { const n = Ge(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 2 === e.type && (r = "class" === (h = r) ? "className" : "for" === h ? "htmlFor" : "formaction" === h ? "formAction" : "innerHtml" === h ? "innerHTML" : "readonly" === h ? "readOnly" : "tabindex" === h ? "tabIndex" : h, s = null != o ? o(s, e.tagName || "", r) : s, $e(i) ? i.setProperty(l, r, s) : Mn(r) || (l.setProperty ? l.setProperty(r, s) : l[r] = s)) } function as(t, e, n, r) { let s = !1; if (nn()) { const i = function (t, e, n) { const r = t.directiveRegistry; let s = null; if (r) for (let i = 0; i < r.length; i++) { const o = r[i]; Rr(n, o.selectors, !1) && (s || (s = []), Jn(Zn(n, e), t, o.type), ke(o) ? (ds(t, n), s.unshift(o)) : s.push(o)) } return s }(t, e, n), o = null === r ? null : { "": -1 }; if (null !== i) { let r = 0; s = !0, fs(n, t.data.length, i.length); for (let t = 0; t < i.length; t++) { const e = i[t]; e.providersResolver && e.providersResolver(e) } hs(t, n, i.length); let a = !1, l = !1; for (let s = 0; s < i.length; s++) { const u = i[s]; n.mergedAttrs = Fn(n.mergedAttrs, u.hostAttrs), gs(t, e, u), ps(t.data.length - 1, u, o), null !== u.contentQueries && (n.flags |= 8), null === u.hostBindings && null === u.hostAttrs && 0 === u.hostVars || (n.flags |= 128); const c = u.type.prototype; !a && (c.ngOnChanges || c.ngOnInit || c.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index - be), a = !0), l || !c.ngOnChanges && !c.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index - be), l = !0), ls(t, u), r += u.hostVars } !function (t, e) { const n = e.directiveEnd, r = t.data, s = e.attrs, i = []; let o = null, a = null; for (let l = e.directiveStart; l < n; l++) { const t = r[l], n = t.inputs, u = null === s || Er(e) ? null : _s(n, s); i.push(u), o = is(n, l, o), a = is(t.outputs, l, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = i, e.inputs = o, e.outputs = a }(t, n), us(t, e, r) } o && function (t, e, n) { if (e) { const r = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const s = n[e[t + 1]]; if (null == s) throw new Error(`Export of name '${e[t + 1]}' not found!`); r.push(e[t], s) } } }(n, r, o) } return n.mergedAttrs = Fn(n.mergedAttrs, n.attrs), s } function ls(t, e) { const n = t.expandoInstructions; n.push(e.hostBindings), 0 !== e.hostVars && n.push(e.hostVars) } function us(t, e, n) { for (let r = 0; r < n; r++)e.push(Vr), t.blueprint.push(Vr), t.data.push(null) } function cs(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function hs(t, e, n) { const r = be - e.index, s = t.data.length - (1048575 & e.providerIndexes); (t.expandoInstructions || (t.expandoInstructions = [])).push(r, s, n) } function ds(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function ps(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; ke(e) && (n[""] = t) } } function fs(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function gs(t, e, n) { t.data.push(n); const r = n.factory || (n.factory = ve(n.type)), s = new Nn(r, ke(n), null); t.blueprint.push(s), e.push(s) } function ms(t, e, n) { const r = We(e, t), s = ns(n), i = t[10], o = Cs(t, Gr(t, s, null, n.onPush ? 64 : 16, r, e, i, i.createRenderer(r, n), null, null)); t[e.index] = o } function ys(t, e, n, r, s, i) { const o = i[e]; if (null !== o) { const t = r.setInput; for (let e = 0; e < o.length;) { const s = o[e++], i = o[e++], a = o[e++]; null !== t ? r.setInput(n, a, s, i) : n[i] = a } } } function _s(t, e) { let n = null, r = 0; for (; r < e.length;) { const s = e[r]; if (0 !== s) if (5 !== s) { if ("number" == typeof s) break; t.hasOwnProperty(s) && (null === n && (n = []), n.push(s, t[s], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function vs(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) } function ws(t, e) { const n = Ge(e, t); if (Je(n)) { const t = n[1]; 80 & n[2] ? Jr(t, n, t.template, n[8]) : n[5] > 0 && function t(e) { for (let r = Nr(e); null !== r; r = Dr(r))for (let e = Ce; e < r.length; e++) { const n = r[e]; if (1024 & n[2]) { const t = n[1]; Jr(t, n, t.template, n[8]) } else n[5] > 0 && t(n) } const n = e[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const s = Ge(n[r], e); Je(s) && s[5] > 0 && t(s) } }(n) } } function bs(t, e) { const n = Ge(e, t), r = n[1]; !function (t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) }(r, n), Kr(r, n, n[8]) } function Cs(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function Ss(t) { for (; t;) { t[2] |= 64; const e = jr(t); if (Oe(t) && !e) return t; t = e } return null } function xs(t, e, n) { const r = e[10]; r.begin && r.begin(); try { Jr(t, e, t.template, n) } catch (s) { throw Os(e, s), s } finally { r.end && r.end() } } function Es(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = Qe(n), s = r[1]; Yr(s, r, s.template, n) } }(t[8]) } function Ts(t, e, n) { yn(0), e(t, n) } const As = (() => Promise.resolve(null))(); function ks(t) { return t[7] || (t[7] = []) } function Os(t, e) { const n = t[9], r = n ? n.get(hr, null) : null; r && r.handleError(e) } function Rs(t, e, n, r, s) { for (let i = 0; i < n.length;) { const o = n[i++], a = n[i++], l = e[o], u = t.data[o]; null !== u.setInput ? u.setInput(l, s, r, a) : l[a] = s } } function Is(t, e, n) { const r = qe(e, t), s = t[11]; $e(s) ? s.setValue(r, n) : r.textContent = n } function Ps(t, e, n, r, s) { if (null != r) { let i, o = !1; xe(r) ? i = r : Se(r) && (o = !0, r = r[0]); const a = Be(r); 0 === t && null !== n ? null == s ? Fs(e, n, a) : Ms(e, n, a, s || null) : 1 === t && null !== n ? Ms(e, n, a, s || null) : 2 === t ? function (t, e, n) { const r = Hs(t, e); r && function (t, e, n, r) { $e(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != i && function (t, e, n, r, s) { const i = n[7]; i !== Be(n) && Ps(e, t, r, i, s); for (let o = Ce; o < n.length; o++) { const s = n[o]; qs(s[1], s, t, e, r, i) } }(e, t, i, n, s) } } function Vs(t, e) { const n = t[9], r = n.indexOf(e), s = e[3]; 1024 & e[2] && (e[2] &= -1025, tn(s, -1)), n.splice(r, 1) } function js(t, e) { if (t.length <= Ce) return; const n = Ce + e, r = t[n]; if (r) { const i = r[17]; null !== i && i !== t && Vs(i, r), e > 0 && (t[n - 1][4] = r[4]); const o = ee(t, Ce + e); qs(r[1], s = r, s[11], 2, null, null), s[0] = null, s[6] = null; const a = o[19]; null !== a && a.detachView(o[1]), r[3] = null, r[4] = null, r[2] &= -129 } var s; return r } function Ns(t, e) { if (!(256 & e[2])) { const n = e[11]; $e(n) && n.destroyNode && qs(t, e, n, 3, null, null), function (t) { let e = t[13]; if (!e) return Ds(t[1], t); for (; e;) { let n = null; if (Se(e)) n = e[13]; else { const t = e[10]; t && (n = t) } if (!n) { for (; e && !e[4] && e !== t;)Se(e) && Ds(e[1], e), e = e[3]; null === e && (e = t), Se(e) && Ds(e[1], e), n = e && e[4] } e = n } }(e) } } function Ds(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const t = e[n[r]]; if (!(t instanceof Nn)) { const e = n[r + 1]; if (Array.isArray(e)) for (let n = 0; n < e.length; n += 2)e[n + 1].call(t[e[n]]); else e.call(t) } } }(t, e), function (t, e) { const n = t.cleanup; if (null !== n) { const t = e[7]; for (let r = 0; r < n.length - 1; r += 2)if ("string" == typeof n[r]) { const s = n[r + 1], i = "function" == typeof s ? s(e) : Be(e[s]), o = t[n[r + 2]], a = n[r + 3]; "boolean" == typeof a ? i.removeEventListener(n[r], o, a) : a >= 0 ? t[a]() : t[-a].unsubscribe(), r += 2 } else n[r].call(t[n[r + 1]]); e[7] = null } }(t, e), 1 === e[1].type && $e(e[11]) && e[11].destroy(); const n = e[17]; if (null !== n && xe(e[3])) { n !== e[3] && Vs(n, e); const r = e[19]; null !== r && r.detachView(t) } } } function Us(t, e, n) { let r = e.parent; for (; null != r && (3 === r.type || 4 === r.type);)r = (e = r).parent; if (null === r) return n[0]; if (e && 4 === e.type && 4 & e.flags) return We(e, n).parentNode; if (2 & r.flags) { const e = t.data, n = e[e[r.index].directiveStart].encapsulation; if (n !== ae.ShadowDom && n !== ae.Native) return null } return We(r, n) } function Ms(t, e, n, r) { $e(t) ? t.insertBefore(e, n, r) : e.insertBefore(n, r, !0) } function Fs(t, e, n) { $e(t) ? t.appendChild(e, n) : e.appendChild(n) } function Ls(t, e, n, r) { null !== r ? Ms(t, e, n, r) : Fs(t, e, n) } function Hs(t, e) { return $e(t) ? t.parentNode(e) : e.parentNode } function $s(t, e) { return 3 === t.type || 4 === t.type ? We(t, e) : null } function zs(t, e, n, r) { const s = Us(t, r, e); if (null != s) { const t = e[11], i = $s(r.parent || e[6], e); if (Array.isArray(n)) for (let e = 0; e < n.length; e++)Ls(t, s, n[e], i); else Ls(t, s, n, i) } } function Bs(t, e, n, r, s, i, o) { for (; null != n;) { const a = r[n.index], l = n.type; o && 0 === e && (a && br(Be(a), r), n.flags |= 4), 64 != (64 & n.flags) && (3 === l || 4 === l ? (Bs(t, e, n.child, r, s, i, !1), Ps(e, t, s, a, i)) : 1 === l ? Ws(t, e, r, n, s, i) : Ps(e, t, s, a, i)), n = o ? n.projectionNext : n.next } } function qs(t, e, n, r, s, i) { Bs(n, r, t.firstChild, e, s, i, !1) } function Ws(t, e, n, r, s, i) { const o = n[16], a = o[6].projection[r.projection]; if (Array.isArray(a)) for (let l = 0; l < a.length; l++)Ps(e, t, s, a[l], i); else Bs(t, e, a, o[3], s, i, !0) } function Zs(t, e, n) { $e(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Gs(t, e, n) { $e(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } class Qs { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._viewContainerRef = null } get rootNodes() { const t = this._lView, e = t[1]; return function t(e, n, r, s, i = !1) { for (; null !== r;) { const o = n[r.index]; if (null !== o && s.push(Be(o)), xe(o)) for (let e = Ce; e < o.length; e++) { const n = o[e], r = n[1].firstChild; null !== r && t(n[1], n, r, s) } const a = r.type; if (3 === a || 4 === a) t(e, n, r.child, s); else if (1 === a) { const e = n[16], i = e[6].projection[r.projection]; if (Array.isArray(i)) s.push(...i); else { const n = jr(e); t(n[1], n, i, s, !0) } } r = i ? r.projectionNext : r.next } return s }(e, t, e.firstChild, []) } get context() { return this._lView[8] } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._viewContainerRef) { const t = this._viewContainerRef.indexOf(this); t > -1 && this._viewContainerRef.detach(t), this._viewContainerRef = null } Ns(this._lView[1], this._lView) } onDestroy(t) { ss(this._lView[1], this._lView, null, t) } markForCheck() { Ss(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { xs(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, n) { hn(!0); try { xs(t, e, n) } finally { hn(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef(t) { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._viewContainerRef = t } detachFromAppRef() { var t; this._appRef = null, qs(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class Ks extends Qs { constructor(t) { super(t), this._view = t } detectChanges() { Es(this._view) } checkNoChanges() { !function (t) { hn(!0); try { Es(t) } finally { hn(!1) } }(this._view) } get context() { return null } } let Js, Ys, Xs; function ti(t, e, n) { return Js || (Js = class extends t { }), new Js(We(e, n)) } function ei(t, e, n, r) { return Ys || (Ys = class extends t { constructor(t, e, n) { super(), this._declarationView = t, this._declarationTContainer = e, this.elementRef = n } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, n = Gr(this._declarationView, e, t, 16, null, e.declTNode, null, null, null, null); n[17] = this._declarationView[this._declarationTContainer.index]; const r = this._declarationView[19]; return null !== r && (n[19] = r.createEmbeddedView(e)), Kr(e, n, t), new Qs(n) } }), 0 === n.type ? new Ys(r, n, ti(e, n, r)) : null } function ni(t, e, n, r) { let s; Xs || (Xs = class extends t { constructor(t, e, n) { super(), this._lContainer = t, this._hostTNode = e, this._hostView = n } get element() { return ti(e, this._hostTNode, this._hostView) } get injector() { return new ir(this._hostTNode, this._hostView) } get parentInjector() { const t = Kn(this._hostTNode, this._hostView); if (Hn(t)) { const e = zn(t, this._hostView), n = $n(t); return new ir(e[1].data[n + 8], e) } return new ir(null, this._hostView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { return null !== this._lContainer[8] && this._lContainer[8][t] || null } get length() { return this._lContainer.length - Ce } createEmbeddedView(t, e, n) { const r = t.createEmbeddedView(e || {}); return this.insert(r, n), r } createComponent(t, e, n, r, s) { const i = n || this.parentInjector; if (!s && null == t.ngModule && i) { const t = i.get(Jt, null); t && (s = t) } const o = t.create(i, r, void 0, s); return this.insert(o.hostView, e), o } insert(t, e) { const n = t._lView, r = n[1]; if (t.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!"); if (this.allocateContainerIfNeeded(), xe(n[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = n[3], r = new Xs(e, e[6], e[3]); r.detach(r.indexOf(t)) } } const s = this._adjustIndex(e), i = this._lContainer; !function (t, e, n, r) { const s = Ce + r, i = n.length; r > 0 && (n[s - 1][4] = e), r < i - Ce ? (e[4] = n[s], te(n, Ce + r, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function (t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(r, n, i, s); const o = function t(e, n) { const r = Ce + e + 1; if (r < n.length) { const e = n[r], s = e[1].firstChild; if (null !== s) return function e(n, r) { if (null !== r) { const s = r.type; if (2 === s) return We(r, n); if (0 === s) return t(-1, n[r.index]); if (3 === s || 4 === s) { const s = r.child; if (null !== s) return e(n, s); { const e = n[r.index]; return xe(e) ? t(-1, e) : Be(e) } } { const t = n[16], s = t[6], i = jr(t), o = s.projection[r.projection]; return null != o ? e(i, o) : e(n, r.next) } } return null }(e, s) } return n[7] }(s, i), a = n[11], l = Hs(a, i[7]); return null !== l && function (t, e, n, r, s, i) { r[0] = s, r[6] = e, qs(t, r, n, 1, s, i) }(r, i[6], a, n, l, o), t.attachToViewContainerRef(this), te(i[8], s, t), t } move(t, e) { if (t.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!"); return this.insert(t, e) } indexOf(t) { const e = this._lContainer[8]; return null !== e ? e.indexOf(t) : -1 } remove(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1), n = js(this._lContainer, e); n && (ee(this._lContainer[8], e), Ns(n[1], n)) } detach(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1), n = js(this._lContainer, e); return n && null != ee(this._lContainer[8], e) ? new Qs(n) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } allocateContainerIfNeeded() { null === this._lContainer[8] && (this._lContainer[8] = []) } }); const i = r[n.index]; if (xe(i)) s = i; else { let t; if (3 === n.type) t = Be(i); else if (t = r[11].createComment(""), Oe(r)) { const e = r[11], s = We(n, r); Ms(e, Hs(e, s), t, function (t, e) { return $e(t) ? t.nextSibling(e) : e.nextSibling }(e, s)) } else zs(r[1], r, t, n); r[n.index] = s = vs(i, r, t, n), Cs(r, s) } return new Xs(s, n, r) } let ri = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => si(), t })(); const si = function (t = !1) { return function (t, e, n) { if (!n && Te(t)) { const n = Ge(t.index, e); return new Qs(n, n) } return 2 === t.type || 0 === t.type || 3 === t.type || 4 === t.type ? new Qs(e[16], e) : null }(on(), rn(), t) }, ii = Function, oi = new Dt("Set Injector scope."), ai = {}, li = {}, ui = []; let ci = void 0; function hi() { return void 0 === ci && (ci = new Kt), ci } function di(t, e = null, n = null, r) { return new pi(t, n, e || hi(), r) } class pi { constructor(t, e, n, r = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; e && Xt(e, n => this.processProvider(n, t, e)), Xt([t], t => this.processInjectorType(t, [], s)), this.records.set(Ut, mi(void 0, this)); const i = this.records.get(oi); this.scope = null != i ? i.value : null, this.source = r || ("object" == typeof t ? null : _t(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = Mt, n = it.Default) { this.assertNotDestroyed(); const r = Bt(this); try { if (!(n & it.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const n = ("function" == typeof (s = t) || "object" == typeof s && s instanceof Dt) && ct(t); e = n && this.injectableDefInScope(n) ? mi(fi(t), ai) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (n & it.Self ? hi() : this.parent).get(t, e = n & it.Optional && e === Mt ? null : e) } catch (i) { if ("NullInjectorError" === i.name) { if ((i.ngTempTokenPath = i.ngTempTokenPath || []).unshift(_t(t)), r) throw i; return function (t, e, n, r) { const s = t.ngTempTokenPath; throw e[Lt] && s.unshift(e[Lt]), t.message = function (t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let s = _t(e); if (Array.isArray(e)) s = e.map(_t).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let r = e[n]; t.push(n + ":" + ("string" == typeof r ? JSON.stringify(r) : _t(r))) } s = `{${t.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${s}]: ${t.replace(Ft, "\n  ")}` }("\n" + t.message, s, n, r), t.ngTokenPath = s, t.ngTempTokenPath = null, t }(i, t, "R3InjectorError", this.source) } throw i } finally { Bt(r) } var s } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, n) => t.push(_t(n))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, n) { if (!(t = Ct(t))) return !1; let r = dt(t); const s = null == r && t.ngModule || void 0, i = void 0 === s ? t : s, o = -1 !== n.indexOf(i); if (void 0 !== s && (r = dt(s)), null == r) return !1; if (null != r.imports && !o) { let t; n.push(i); try { Xt(r.imports, r => { this.processInjectorType(r, e, n) && (void 0 === t && (t = []), t.push(r)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: n, providers: r } = t[e]; Xt(r, t => this.processProvider(t, n, r || ui)) } } this.injectorDefTypes.add(i), this.records.set(i, mi(r.factory, ai)); const a = r.providers; if (null != a && !o) { const e = t; Xt(a, t => this.processProvider(t, e, a)) } return void 0 !== s && void 0 !== t.providers } processProvider(t, e, n) { let r = _i(t = Ct(t)) ? t : Ct(t && t.provide); const s = function (t, e, n) { return yi(t) ? mi(void 0, t.useValue) : mi(gi(t), ai) }(t); if (_i(t) || !0 !== t.multi) this.records.get(r); else { let e = this.records.get(r); e || (e = mi(void 0, ai, !0), e.factory = () => Qt(e.multi), this.records.set(r, e)), r = t, e.multi.push(t) } this.records.set(r, s) } hydrate(t, e) { var n; return e.value === ai && (e.value = li, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { return !!t.providedIn && ("string" == typeof t.providedIn ? "any" === t.providedIn || t.providedIn === this.scope : this.injectorDefTypes.has(t.providedIn)) } } function fi(t) { const e = ct(t), n = null !== e ? e.factory : ve(t); if (null !== n) return n; const r = dt(t); if (null !== r) return r.factory; if (t instanceof Dt) throw new Error(`Token ${_t(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const n = ne(e, "?"); throw new Error(`Can't resolve all parameters for ${_t(t)}: (${n.join(", ")}).`) } const n = function (t) { const e = t && (t[pt] || t[mt] || t[gt] && t[gt]()); if (e) { const n = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new Error("unreachable") } function gi(t, e, n) { let r = void 0; if (_i(t)) { const e = Ct(t); return ve(e) || fi(e) } if (yi(t)) r = () => Ct(t.useValue); else if ((s = t) && s.useFactory) r = () => t.useFactory(...Qt(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) r = () => Zt(Ct(t.useExisting)); else { const e = Ct(t && (t.useClass || t.provide)); if (!function (t) { return !!t.deps }(t)) return ve(e) || fi(e); r = () => new e(...Qt(t.deps)) } var s; return r } function mi(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function yi(t) { return null !== t && "object" == typeof t && Ht in t } function _i(t) { return "function" == typeof t } const vi = function (t, e, n) { return function (t, e = null, n = null, r) { const s = di(t, e, n, r); return s._resolveInjectorDefTypes(), s }({ name: n }, e, t, n) }; let wi = (() => { class t { static create(t, e) { return Array.isArray(t) ? vi(t, e, "") : vi(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = Mt, t.NULL = new Kt, t.\u0275prov = lt({ token: t, providedIn: "any", factory: () => Zt(Ut) }), t.__NG_ELEMENT_ID__ = -1, t })(); const bi = new Dt("AnalyzeForEntryComponents"); function Ci(t, e, n) { let r = n ? t.styles : null, s = n ? t.classes : null, i = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const t = e[o]; "number" == typeof t ? i = t : 1 == i ? s = vt(s, t) : 2 == i && (r = vt(r, t + ": " + e[++o] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = s : t.classesWithoutHost = s } function Si(t, e) { const n = Qe(t)[1], r = n.data.length - 1; kn(n, { directiveStart: r, directiveEnd: r + 1 }) } function xi(t) { let e = Object.getPrototypeOf(t.type.prototype).constructor, n = !0; const r = [t]; for (; e;) { let s = void 0; if (ke(t)) s = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components"); s = e.\u0275dir } if (s) { if (n) { r.push(s); const e = t; e.inputs = Ei(t.inputs), e.declaredInputs = Ei(t.declaredInputs), e.outputs = Ei(t.outputs); const n = s.hostBindings; n && ki(t, n); const i = s.viewQuery, o = s.contentQueries; if (i && Ti(t, i), o && Ai(t, o), at(t.inputs, s.inputs), at(t.declaredInputs, s.declaredInputs), at(t.outputs, s.outputs), ke(s) && s.data.animation) { const e = t.data; e.animation = (e.animation || []).concat(s.data.animation) } } const e = s.features; if (e) for (let r = 0; r < e.length; r++) { const s = e[r]; s && s.ngInherit && s(t), s === xi && (n = !1) } } e = Object.getPrototypeOf(e) } !function (t) { let e = 0, n = null; for (let r = t.length - 1; r >= 0; r--) { const s = t[r]; s.hostVars = e += s.hostVars, s.hostAttrs = Fn(s.hostAttrs, n = Fn(n, s.hostAttrs)) } }(r) } function Ei(t) { return t === le ? {} : t === ue ? [] : t } function Ti(t, e) { const n = t.viewQuery; t.viewQuery = n ? (t, r) => { e(t, r), n(t, r) } : e } function Ai(t, e) { const n = t.contentQueries; t.contentQueries = n ? (t, r, s) => { e(t, r, s), n(t, r, s) } : e } function ki(t, e) { const n = t.hostBindings; t.hostBindings = n ? (t, r) => { e(t, r), n(t, r) } : e } let Oi = null; function Ri() { if (!Oi) { const t = kt.Symbol; if (t && t.iterator) Oi = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (Oi = n) } } } return Oi } function Ii(t) { return !!Pi(t) && (Array.isArray(t) || !(t instanceof Map) && Ri() in t) } function Pi(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function Vi(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function ji(t, e, n, r) { const s = rn(); return Vi(s, dn(), e) && (sn(), function (t, e, n, r, s, i) { const o = We(t, e), a = e[11]; if (null == r) $e(a) ? a.removeAttribute(o, n, i) : o.removeAttribute(n); else { const e = null == s ? Re(r) : s(r, t.tagName || "", n); $e(a) ? a.setAttribute(o, n, e, i) : i ? o.setAttributeNS(i, n, e) : o.setAttribute(n, e) } }(An(), s, t, e, n, r)), ji } function Ni(t, e, n, r, s, i, o, a) { const l = rn(), u = sn(), c = t + be, h = u.firstCreatePass ? function (t, e, n, r, s, i, o, a, l) { const u = e.consts, c = Qr(e, t, 0, o || null, Ye(u, a)); as(e, n, c, Ye(u, l)), kn(e, c); const h = c.tViews = rs(2, c, r, s, i, e.directiveRegistry, e.pipeRegistry, null, e.schemas, u); return null !== e.queries && (e.queries.template(e, c), h.queries = e.queries.embeddedTView(c)), c }(t, u, l, e, n, r, s, i, o) : u.data[c]; an(h, !1); const d = l[11].createComment(""); zs(u, l, d, h), br(d, l), Cs(l, l[c] = vs(d, l, d, h)), Ae(h) && ts(u, l, h), null != o && es(l, h, a) } function Di(t, e = it.Default) { const n = rn(); return null === n ? Zt(t, e) : Yn(on(), n, Ct(t), e) } function Ui(t, e, n) { const r = rn(); return Vi(r, dn(), e) && os(sn(), An(), r, t, e, r[11], n, !1), Ui } function Mi(t, e, n, r, s) { const i = s ? "class" : "style"; Rs(t, n, e.inputs[i], i, r) } function Fi(t, e, n, r) { const s = rn(), i = sn(), o = be + t, a = s[11], l = s[o] = Zr(e, a, en.lFrame.currentNamespace), u = i.firstCreatePass ? function (t, e, n, r, s, i, o) { const a = e.consts, l = Qr(e, t, 2, s, Ye(a, i)); return as(e, n, l, Ye(a, o)), null !== l.attrs && Ci(l, l.attrs, !1), null !== l.mergedAttrs && Ci(l, l.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, l), l }(t, i, s, 0, e, n, r) : i.data[o]; an(u, !0); const c = u.mergedAttrs; null !== c && Dn(a, l, c); const h = u.classes; null !== h && Gs(a, l, h); const d = u.styles; null !== d && Zs(a, l, d), zs(i, s, l, u), 0 === en.lFrame.elementDepthCount && br(l, s), en.lFrame.elementDepthCount++ , Ae(u) && (ts(i, s, u), function (t, e, n) { if (Ee(e)) { const r = e.directiveEnd; for (let s = e.directiveStart; s < r; s++) { const e = t.data[s]; e.contentQueries && e.contentQueries(1, n[s], s) } } }(i, u, s)), null !== r && es(s, u) } function Li() { let t = on(); ln() ? un() : (t = t.parent, an(t, !1)); const e = t; en.lFrame.elementDepthCount--; const n = sn(); n.firstCreatePass && (kn(n, t), Ee(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function (t) { return 0 != (16 & t.flags) }(e) && Mi(n, e, rn(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function (t) { return 0 != (32 & t.flags) }(e) && Mi(n, e, rn(), e.stylesWithoutHost, !1) } function Hi(t, e, n, r) { Fi(t, e, n, r), Li() } function $i(t) { return !!t && "function" == typeof t.then } function zi(t) { return !!t && "function" == typeof t.subscribe } function Bi(t, e, n = !1, r) { const s = rn(), i = sn(), o = on(); return function (t, e, n, r, s, i, o = !1, a) { const l = Ae(r), u = t.firstCreatePass && (t.cleanup || (t.cleanup = [])), c = ks(e); let h = !0; if (2 === r.type) { const d = We(r, e), p = a ? a(d) : le, f = p.target || d, g = c.length, m = a ? t => a(Be(t[r.index])).target : r.index; if ($e(n)) { let o = null; if (!a && l && (o = function (t, e, n, r) { const s = t.cleanup; if (null != s) for (let i = 0; i < s.length - 1; i += 2) { const t = s[i]; if (t === n && s[i + 1] === r) { const t = e[7], n = s[i + 2]; return t.length > n ? t[n] : null } "string" == typeof t && (i += 2) } return null }(t, e, s, r.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = i, o.__ngLastListenerFn__ = i, h = !1; else { i = Wi(r, e, i, !1); const t = n.listen(p.name || f, s, i); c.push(i, t), u && u.push(s, m, g, g + 1) } } else i = Wi(r, e, i, !0), f.addEventListener(s, i, o), c.push(i), u && u.push(s, m, g, o) } const d = r.outputs; let p; if (h && null !== d && (p = d[s])) { const t = p.length; if (t) for (let n = 0; n < t; n += 2) { const t = e[p[n]][p[n + 1]].subscribe(i), o = c.length; c.push(i, t), u && u.push(s, r.index, o, -(o + 1)) } } }(i, s, s[11], o, t, e, n, r), Bi } function qi(t, e, n) { try { return !1 !== e(n) } catch (r) { return Os(t, r), !1 } } function Wi(t, e, n, r) { return function s(i) { if (i === Function) return n; const o = 2 & t.flags ? Ge(t.index, e) : e; 0 == (32 & e[2]) && Ss(o); let a = qi(e, n, i), l = s.__ngNextListenerFn__; for (; l;)a = qi(e, l, i) && a, l = l.__ngNextListenerFn__; return r && !1 === a && (i.preventDefault(), i.returnValue = !1), a } } function Zi(t = 1) { return function (t) { return (en.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, en.lFrame.contextLView))[8] }(t) } const Gi = []; function Qi(t, e, n, r, s) { const i = t[n + 1], o = null === e; let a = r ? Hr(i) : zr(i), l = !1; for (; 0 !== a && (!1 === l || o);) { const n = t[a + 1]; Ki(t[a], e) && (l = !0, t[a + 1] = r ? qr(n) : $r(n)), a = r ? Hr(n) : zr(n) } l && (t[n + 1] = r ? $r(i) : qr(i)) } function Ki(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && ie(t, e) >= 0 } const Ji = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function Yi(t) { return t.substring(Ji.key, Ji.keyEnd) } function Xi(t, e) { const n = Ji.textEnd; return n === e ? -1 : (e = Ji.keyEnd = function (t, e, n) { for (; e < n && t.charCodeAt(e) > 32;)e++; return e }(t, Ji.key = e, n), to(t, e, n)) } function to(t, e, n) { for (; e < n && t.charCodeAt(e) <= 32;)e++; return e } function eo(t, e) { return function (t, e, n, r) { const s = rn(), i = sn(), o = pn(2); i.firstUpdatePass && io(i, t, o, true), e !== Vr && Vi(s, o, e) && lo(i, i.data[En() + be], s, s[11], t, s[o + 1] = function (t, e) { return null == t || "object" == typeof t && (t = _t(pr(t))), t }(e), true, o) }(t, e), eo } function no(t) { !function (t, e, n, r) { const s = sn(), i = pn(2); s.firstUpdatePass && io(s, null, i, r); const o = rn(); if (n !== Vr && Vi(o, i, n)) { const a = s.data[En() + be]; if (ho(a, r) && !so(s, i)) { let t = a.classesWithoutHost; null !== t && (n = vt(t, n || "")), Mi(s, a, o, n, r) } else !function (t, e, n, r, s, i, o, a) { s === Vr && (s = Gi); let l = 0, u = 0, c = 0 < s.length ? s[0] : null, h = 0 < i.length ? i[0] : null; for (; null !== c || null !== h;) { const o = l < s.length ? s[l + 1] : void 0, d = u < i.length ? i[u + 1] : void 0; let p = null, f = void 0; c === h ? (l += 2, u += 2, o !== d && (p = h, f = d)) : null === h || null !== c && c < h ? (l += 2, p = c) : (u += 2, p = h, f = d), null !== p && lo(t, e, n, r, p, f, true, a), c = l < s.length ? s[l] : null, h = u < i.length ? i[u] : null } }(s, a, o, o[11], o[i + 1], o[i + 1] = function (t, e, n) { if (null == n || "" === n) return Gi; const r = [], s = pr(n); if (Array.isArray(s)) for (let i = 0; i < s.length; i++)t(r, s[i], !0); else if ("object" == typeof s) for (const i in s) s.hasOwnProperty(i) && t(r, i, s[i]); else "string" == typeof s && e(r, s); return r }(t, e, n), 0, i) } }(re, ro, t, !0) } function ro(t, e) { for (let n = function (t) { return function (t) { Ji.key = 0, Ji.keyEnd = 0, Ji.value = 0, Ji.valueEnd = 0, Ji.textEnd = t.length }(t), Xi(t, to(t, 0, Ji.textEnd)) }(e); n >= 0; n = Xi(e, n))re(t, Yi(e), !0) } function so(t, e) { return e >= t.expandoStartIndex } function io(t, e, n, r) { const s = t.data; if (null === s[n + 1]) { const i = s[En() + be], o = so(t, n); ho(i, r) && null === e && !o && (e = !1), e = function (t, e, n, r) { const s = function (t) { const e = en.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] }(t); let i = r ? e.residualClasses : e.residualStyles; if (null === s) 0 === (r ? e.classBindings : e.styleBindings) && (n = ao(n = oo(null, t, e, n, r), e.attrs, r), i = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== s) if (n = oo(s, t, e, n, r), null === i) { let n = function (t, e, n) { const r = n ? e.classBindings : e.styleBindings; if (0 !== zr(r)) return t[Hr(r)] }(t, e, r); void 0 !== n && Array.isArray(n) && (n = oo(null, t, e, n[1], r), n = ao(n, e.attrs, r), function (t, e, n, r) { t[Hr(n ? e.classBindings : e.styleBindings)] = r }(t, e, r, n)) } else i = function (t, e, n) { let r = void 0; const s = e.directiveEnd; for (let i = 1 + e.directiveStylingLast; i < s; i++)r = ao(r, t[i].hostAttrs, n); return ao(r, e.attrs, n) }(t, e, r) } return void 0 !== i && (r ? e.residualClasses = i : e.residualStyles = i), n }(s, i, e, r), function (t, e, n, r, s, i) { let o = i ? e.classBindings : e.styleBindings, a = Hr(o), l = zr(o); t[r] = n; let u, c = !1; if (Array.isArray(n)) { const t = n; u = t[1], (null === u || ie(t, u) > 0) && (c = !0) } else u = n; if (s) if (0 !== l) { const e = Hr(t[a + 1]); t[r + 1] = Lr(e, a), 0 !== e && (t[e + 1] = Br(t[e + 1], r)), t[a + 1] = 131071 & t[a + 1] | r << 17 } else t[r + 1] = Lr(a, 0), 0 !== a && (t[a + 1] = Br(t[a + 1], r)), a = r; else t[r + 1] = Lr(l, 0), 0 === a ? a = r : t[l + 1] = Br(t[l + 1], r), l = r; c && (t[r + 1] = $r(t[r + 1])), Qi(t, u, r, !0), Qi(t, u, r, !1), function (t, e, n, r, s) { const i = s ? t.residualClasses : t.residualStyles; null != i && "string" == typeof e && ie(i, e) >= 0 && (n[r + 1] = qr(n[r + 1])) }(e, u, t, r, i), o = Lr(a, l), i ? e.classBindings = o : e.styleBindings = o }(s, i, e, n, o, r) } } function oo(t, e, n, r, s) { let i = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (i = e[a], r = ao(r, i.hostAttrs, s), i !== t);)a++; return null !== t && (n.directiveStylingLast = a), r } function ao(t, e, n) { const r = n ? 1 : 2; let s = -1; if (null !== e) for (let i = 0; i < e.length; i++) { const o = e[i]; "number" == typeof o ? s = o : s === r && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), re(t, o, !!n || e[++i])) } return void 0 === t ? null : t } function lo(t, e, n, r, s, i, o, a) { if (2 !== e.type) return; const l = t.data, u = l[a + 1]; co(1 == (1 & u) ? uo(l, e, n, s, zr(u), o) : void 0) || (co(i) || 2 == (2 & u) && (i = uo(l, null, n, s, a, o)), function (t, e, n, r, s) { const i = $e(t); if (e) s ? i ? t.addClass(n, r) : n.classList.add(r) : i ? t.removeClass(n, r) : n.classList.remove(r); else { const e = -1 == r.indexOf("-") ? void 0 : 2; null == s ? i ? t.removeStyle(n, r, e) : n.style.removeProperty(r) : i ? t.setStyle(n, r, s, e) : n.style.setProperty(r, s) } }(r, o, qe(En(), n), s, i)) } function uo(t, e, n, r, s, i) { const o = null === e; let a = void 0; for (; s > 0;) { const e = t[s], i = Array.isArray(e), l = i ? e[1] : e, u = null === l; let c = n[s + 1]; c === Vr && (c = u ? Gi : void 0); let h = u ? se(c, r) : l === r ? c : void 0; if (i && !co(h) && (h = se(e, r)), co(h) && (a = h, o)) return a; const d = t[s + 1]; s = o ? Hr(d) : zr(d) } if (null !== e) { let t = i ? e.residualClasses : e.residualStyles; null != t && (a = se(t, r)) } return a } function co(t) { return void 0 !== t } function ho(t, e) { return 0 != (t.flags & (e ? 16 : 32)) } function po(t, e = "") { const n = rn(), r = sn(), s = t + be, i = r.firstCreatePass ? Qr(r, t, 2, null, null) : r.data[s], o = n[s] = function (t, e) { return $e(e) ? e.createText(t) : e.createTextNode(t) }(e, n[11]); zs(r, n, o, i), an(i, !1) } function fo(t) { return go("", t, ""), fo } function go(t, e, n) { const r = rn(), s = function (t, e, n, r) { return Vi(t, dn(), n) ? e + Re(n) + r : Vr }(r, t, e, n); return s !== Vr && Is(r, En(), s), go } function mo(t, e, n, r, s) { const i = rn(), o = function (t, e, n, r, s, i) { const o = function (t, e, n, r) { const s = Vi(t, e, n); return Vi(t, e + 1, r) || s }(t, en.lFrame.bindingIndex, n, s); return pn(2), o ? e + Re(n) + r + Re(s) + i : Vr }(i, t, e, n, r, s); return o !== Vr && Is(i, En(), o), mo } function yo(t, e, n) { const r = rn(); return Vi(r, dn(), e) && os(sn(), An(), r, t, e, r[11], n, !0), yo } const _o = void 0; var vo = ["en", [["a", "p"], ["AM", "PM"], _o], [["AM", "PM"], _o, _o], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], _o, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], _o, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", _o, "{1} 'at' {0}", _o], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; let wo = {}; function bo(t) { return t in wo || (wo[t] = kt.ng && kt.ng.common && kt.ng.common.locales && kt.ng.common.locales[t]), wo[t] } var Co = function (t) { return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t }({}); const So = "en-US"; let xo = So; function Eo(t) { var e, n; n = "Expected localeId to be defined", null == (e = t) && function (t, e, n, r) { throw new Error("ASSERTION ERROR: " + t + ` [Expected=> null != ${e} <=Actual]`) }(n, e), "string" == typeof t && (xo = t.toLowerCase().replace(/_/g, "-")) } function To(t, e, n, r, s) { if (t = Ct(t), Array.isArray(t)) for (let i = 0; i < t.length; i++)To(t[i], e, n, r, s); else { const i = sn(), o = rn(); let a = _i(t) ? t : Ct(t.provide), l = gi(t); const u = on(), c = 1048575 & u.providerIndexes, h = u.directiveStart, d = u.providerIndexes >> 20; if (_i(t) || !t.multi) { const r = new Nn(l, s, Di), p = Oo(a, e, s ? c : c + d, h); -1 === p ? (Jn(Zn(u, o), i, a), Ao(i, t, e.length), e.push(a), u.directiveStart++ , u.directiveEnd++ , s && (u.providerIndexes += 1048576), n.push(r), o.push(r)) : (n[p] = r, o[p] = r) } else { const p = Oo(a, e, c + d, h), f = Oo(a, e, c, c + d), g = p >= 0 && n[p], m = f >= 0 && n[f]; if (s && !m || !s && !g) { Jn(Zn(u, o), i, a); const c = function (t, e, n, r, s) { const i = new Nn(t, n, Di); return i.multi = [], i.index = e, i.componentProviders = 0, ko(i, s, r && !n), i }(s ? Io : Ro, n.length, s, r, l); !s && m && (n[f].providerFactory = c), Ao(i, t, e.length, 0), e.push(a), u.directiveStart++ , u.directiveEnd++ , s && (u.providerIndexes += 1048576), n.push(c), o.push(c) } else Ao(i, t, p > -1 ? p : f, ko(n[s ? f : p], l, !s && r)); !s && r && m && n[f].componentProviders++ } } } function Ao(t, e, n, r) { const s = _i(e); if (s || e.useClass) { const i = (e.useClass || e).prototype.ngOnDestroy; if (i) { const o = t.destroyHooks || (t.destroyHooks = []); if (!s && e.multi) { const t = o.indexOf(n); -1 === t ? o.push(n, [r, i]) : o[t + 1].push(r, i) } else o.push(n, i) } } } function ko(t, e, n) { return n && t.componentProviders++ , t.multi.push(e) - 1 } function Oo(t, e, n, r) { for (let s = n; s < r; s++)if (e[s] === t) return s; return -1 } function Ro(t, e, n, r) { return Po(this.multi, []) } function Io(t, e, n, r) { const s = this.multi; let i; if (this.providerFactory) { const t = this.providerFactory.componentProviders, e = nr(n, n[1], this.providerFactory.index, r); i = e.slice(0, t), Po(s, i); for (let n = t; n < e.length; n++)i.push(e[n]) } else i = [], Po(s, i); return i } function Po(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function Vo(t, e = []) { return n => { n.providersResolver = (n, r) => function (t, e, n) { const r = sn(); if (r.firstCreatePass) { const s = ke(t); To(n, r.data, r.blueprint, s, !0), To(e, r.data, r.blueprint, s, !1) } }(n, r ? r(t) : t, e) } } class jo { } class No { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${_t(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let Do = (() => { class t { } return t.NULL = new No, t })(), Uo = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = () => Mo(t), t })(); const Mo = function (t) { return ti(t, on(), rn()) }; class Fo { } var Lo = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }({}); let Ho = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => $o(), t })(); const $o = function () { const t = rn(), e = Ge(on().index, t); return function (t) { const e = t[11]; if ($e(e)) return e; throw new Error("Cannot inject Renderer2 when the application uses Renderer3!") }(Se(e) ? e : t) }; let zo = (() => { class t { } return t.\u0275prov = lt({ token: t, providedIn: "root", factory: () => null }), t })(); class Bo { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const qo = new Bo("10.2.2"); class Wo { constructor() { } supports(t) { return Ii(t) } create(t) { return new Go(t) } } const Zo = (t, e) => e; class Go { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || Zo } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, r = 0, s = null; for (; e || n;) { const i = !n || e && e.currentIndex < Yo(n, r, s) ? e : n, o = Yo(i, r, s), a = i.currentIndex; if (i === n) r-- , n = n._nextRemoved; else if (e = e._next, null == i.previousIndex) r++; else { s || (s = []); const t = o - r, e = a - r; if (t != e) { for (let n = 0; n < t; n++) { const r = n < s.length ? s[n] : s[n] = 0, i = r + n; e <= i && i < t && (s[n] = r + 1) } s[i.previousIndex] = e - t } } o !== a && t(i, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Ii(t)) throw new Error(`Error trying to diff '${_t(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, r, s = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], r = this._trackByFn(e, n), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, n, r, e)), Object.is(s.item, n) || this._addIdentityChange(s, n)) : (s = this._mismatch(s, n, r, e), i = !0), s = s._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[Ri()](); let r; for (; !(r = n.next()).done;)e(r.value) } }(t, t => { r = this._trackByFn(e, t), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, t, r, e)), Object.is(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, r, e), i = !0), s = s._next, e++ }), this.length = e; return this._truncate(s), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, r) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, r)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, r)) : null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, r)) : t = this._addAfter(new Qo(e, n), s, r), t } _verifyReinsertion(t, e, n, r) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== s ? t = this._reinsertAfter(s, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, s = t._nextRemoved; return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new Jo), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Jo), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class Qo { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class Ko { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && Object.is(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class Jo { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new Ko, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Yo(t, e, n) { const r = t.previousIndex; if (null === r) return r; let s = 0; return n && r < n.length && (s = n[r]), r + e + s } class Xo { constructor() { } supports(t) { return t instanceof Map || Pi(t) } create() { return new ta } } class ta { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || Pi(t))) throw new Error(`Error trying to diff '${_t(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const r = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, r) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const r = n._prev, s = n._next; return r && (r._next = s), s && (s._prev = r), n._next = null, n._prev = null, n } const n = new ea(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class ea { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } let na = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend IterableDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new st, new nt]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.\u0275prov = lt({ token: t, providedIn: "root", factory: () => new t([new Wo]) }), t })(), ra = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend KeyValueDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new st, new nt]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = lt({ token: t, providedIn: "root", factory: () => new t([new Xo]) }), t })(); const sa = [new Xo], ia = new na([new Wo]), oa = new ra(sa); let aa = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => la(t, Uo), t })(); const la = function (t, e) { return ei(t, e, on(), rn()) }; let ua = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => ca(t, Uo), t })(); const ca = function (t, e) { return ni(t, e, on(), rn()) }, ha = {}; class da extends Do { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = _e(t); return new ga(e, this.ngModule) } } function pa(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } const fa = new Dt("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Pe }); class ga extends jo { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(Pr).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return pa(this.componentDef.inputs) } get outputs() { return pa(this.componentDef.outputs) } create(t, e, n, r) { const s = (r = r || this.ngModule) ? function (t, e) { return { get: (n, r, s) => { const i = t.get(n, ha, s); return i !== ha || r === ha ? i : e.get(n, r, s) } } }(t, r.injector) : t, i = s.get(Fo, ze), o = s.get(zo, null), a = i.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", u = n ? function (t, e, n) { if ($e(t)) return t.selectRootElement(e, n === ae.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(a, n, this.componentDef.encapsulation) : Zr(l, i.createRenderer(null, this.componentDef), function (t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(l)), c = this.componentDef.onPush ? 576 : 528, h = { components: [], scheduler: Pe, clean: As, playerHandler: null, flags: 0 }, d = rs(0, null, null, 1, 0, null, null, null, null, null), p = Gr(null, d, h, c, null, null, i, a, o, s); let f, g; vn(p); try { const t = function (t, e, n, r, s, i) { const o = n[1]; n[20] = t; const a = Qr(o, 0, 2, null, null), l = a.mergedAttrs = e.hostAttrs; null !== l && (Ci(a, l, !0), null !== t && (Dn(s, t, l), null !== a.classes && Gs(s, t, a.classes), null !== a.styles && Zs(s, t, a.styles))); const u = r.createRenderer(t, e), c = Gr(n, ns(e), null, e.onPush ? 64 : 16, n[20], a, r, u, null, null); return o.firstCreatePass && (Jn(Zn(a, n), o, e.type), ds(o, a), fs(a, n.length, 1)), Cs(n, c), n[20] = c }(u, this.componentDef, p, i, a); if (u) if (n) Dn(a, u, ["ng-version", qo.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], n = []; let r = 1, s = 2; for (; r < t.length;) { let i = t[r]; if ("string" == typeof i) 2 === s ? "" !== i && e.push(i, t[++r]) : 8 === s && n.push(i); else { if (!kr(s)) break; s = i } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); t && Dn(a, u, t), e && e.length > 0 && Gs(a, u, e.join(" ")) } if (g = Ze(d, 0), void 0 !== e) { const t = g.projection = []; for (let n = 0; n < this.ngContentSelectors.length; n++) { const r = e[n]; t.push(null != r ? Array.from(r) : null) } } f = function (t, e, n, r, s) { const i = n[1], o = function (t, e, n) { const r = on(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), hs(t, r, 1), gs(t, e, n)); const s = nr(e, t, e.length - 1, r); br(s, e); const i = We(r, e); return i && br(i, e), s }(i, n, e); r.components.push(o), t[8] = o, s && s.forEach(t => t(o, e)), e.contentQueries && e.contentQueries(1, o, n.length - 1); const a = on(); if (i.firstCreatePass && (null !== e.hostBindings || null !== e.hostAttrs)) { Tn(a.index - be); const t = n[1]; ls(t, e), us(t, n, e.hostVars), cs(e, o) } return o }(t, this.componentDef, p, h, [Si]), Kr(d, p, null) } finally { xn() } return new ma(this.componentType, f, ti(Uo, g, p), p, g) } } class ma extends class { }{ constructor(t, e, n, r, s) { super(), this.location = n, this._rootLView = r, this._tNode = s, this.destroyCbs = [], this.instance = e, this.hostView = this.changeDetectorRef = new Ks(r), this.componentType = t } get injector() { return new ir(this._tNode, this._rootLView) } destroy() { this.destroyCbs && (this.destroyCbs.forEach(t => t()), this.destroyCbs = null, !this.hostView.destroyed && this.hostView.destroy()) } onDestroy(t) { this.destroyCbs && this.destroyCbs.push(t) } } const ya = new Map; class _a extends Jt { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new da(this); const n = we(t), r = t[Vt] || null; r && Eo(r), this._bootstrapComponents = Ve(n.bootstrap), this._r3Injector = di(t, e, [{ provide: Jt, useValue: this }, { provide: Do, useValue: this.componentFactoryResolver }], _t(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = wi.THROW_IF_NOT_FOUND, n = it.Default) { return t === wi || t === Jt || t === Ut ? this : this._r3Injector.get(t, e, n) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class va extends Yt { constructor(t) { super(), this.moduleType = t, null !== we(t) && function (t) { const e = new Set; !function t(n) { const r = we(n, !0), s = r.id; null !== s && (function (t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${_t(e)} vs ${_t(e.name)}`) }(s, ya.get(s), n), ya.set(s, n)); const i = Ve(r.imports); for (const o of i) e.has(o) || (e.add(o), t(o)) }(t) }(t) } create(t) { return new _a(this.moduleType, t) } } const wa = class extends S { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { let r, s = t => null, i = () => null; t && "object" == typeof t ? (r = this.__isAsync ? e => { setTimeout(() => t.next(e)) } : e => { t.next(e) }, t.error && (s = this.__isAsync ? e => { setTimeout(() => t.error(e)) } : e => { t.error(e) }), t.complete && (i = this.__isAsync ? () => { setTimeout(() => t.complete()) } : () => { t.complete() })) : (r = this.__isAsync ? e => { setTimeout(() => t(e)) } : e => { t(e) }, e && (s = this.__isAsync ? t => { setTimeout(() => e(t)) } : t => { e(t) }), n && (i = this.__isAsync ? () => { setTimeout(() => n()) } : () => { n() })); const o = super.subscribe(r, s, i); return t instanceof h && t.add(o), o } }; function ba() { return this._results[Ri()]() } class Ca { constructor() { this.dirty = !0, this._results = [], this.changes = new wa, this.length = 0; const t = Ri(), e = Ca.prototype; e[t] || (e[t] = ba) } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t) { this._results = function t(e, n) { void 0 === n && (n = e); for (let r = 0; r < e.length; r++) { let s = e[r]; Array.isArray(s) ? (n === e && (n = e.slice(0, r)), t(s, n)) : n !== e && n.push(s) } return n }(t), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0] } notifyOnChanges() { this.changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class Sa { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Sa(this.queryList) } setDirty() { this.queryList.setDirty() } } class xa { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const n = null !== t.contentQueries ? t.contentQueries[0] : e.length, r = []; for (let t = 0; t < n; t++) { const n = e.getByIndex(t); r.push(this.queries[n.indexInDeclarationView].clone()) } return new xa(r) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== Ia(t, e).matches && this.queries[e].setDirty() } } class Ea { constructor(t, e, n, r = null) { this.predicate = t, this.descendants = e, this.isStatic = n, this.read = r } } class Ta { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let n = 0; n < this.length; n++) { const r = null !== e ? e.length : 0, s = this.getByIndex(n).embeddedTView(t, r); s && (s.indexInDeclarationView = n, null !== e ? e.push(s) : e = [s]) } return null !== e ? new Ta(e) : null } template(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Aa { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Aa(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && !1 === this.metadata.descendants) { const e = this._declarationNodeIndex; let n = t.parent; for (; null !== n && 3 === n.type && n.index !== e;)n = n.parent; return e === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const n = this.metadata.predicate; if (Array.isArray(n)) for (let r = 0; r < n.length; r++) { const s = n[r]; this.matchTNodeWithReadOption(t, e, ka(e, s)), this.matchTNodeWithReadOption(t, e, er(e, t, s, !1, !1)) } else n === aa ? 0 === e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, er(e, t, n, !1, !1)) } matchTNodeWithReadOption(t, e, n) { if (null !== n) { const r = this.metadata.read; if (null !== r) if (r === Uo || r === ua || r === aa && 0 === e.type) this.addMatch(e.index, -2); else { const n = er(e, t, r, !1, !1); null !== n && this.addMatch(e.index, n) } else this.addMatch(e.index, n) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function ka(t, e) { const n = t.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1]; return null } function Oa(t, e, n, r) { return -1 === n ? function (t, e) { return 2 === t.type || 3 === t.type ? ti(Uo, t, e) : 0 === t.type ? ei(aa, Uo, t, e) : null }(e, t) : -2 === n ? function (t, e, n) { return n === Uo ? ti(Uo, e, t) : n === aa ? ei(aa, Uo, e, t) : n === ua ? ni(ua, Uo, e, t) : void 0 }(t, e, r) : nr(t, t[1], n, e) } function Ra(t, e, n, r) { const s = e[19].queries[r]; if (null === s.matches) { const r = t.data, i = n.matches, o = []; for (let t = 0; t < i.length; t += 2) { const s = i[t]; o.push(s < 0 ? null : Oa(e, r[s], i[t + 1], n.metadata.read)) } s.matches = o } return s.matches } function Ia(t, e) { return t.queries.getByIndex(e) } const Pa = new Dt("Application Initializer"); let Va = (() => { class t { constructor(t) { this.appInits = t, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); $i(e) && t.push(e) } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Pa, 8)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const ja = new Dt("AppId"), Na = { provide: ja, useFactory: function () { return `${Da()}${Da()}${Da()}` }, deps: [] }; function Da() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const Ua = new Dt("Platform Initializer"), Ma = new Dt("Platform ID"), Fa = new Dt("appBootstrapListener"); let La = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const Ha = new Dt("LocaleId"), $a = new Dt("DefaultCurrencyCode"); class za { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const Ba = function (t) { return new va(t) }, qa = Ba, Wa = function (t) { return Promise.resolve(Ba(t)) }, Za = function (t) { const e = Ba(t), n = Ve(we(t).declarations).reduce((t, e) => { const n = _e(e); return n && t.push(new ga(n)), t }, []); return new za(e, n) }, Ga = Za, Qa = function (t) { return Promise.resolve(Za(t)) }; let Ka = (() => { class t { constructor() { this.compileModuleSync = qa, this.compileModuleAsync = Wa, this.compileModuleAndAllComponentsSync = Ga, this.compileModuleAndAllComponentsAsync = Qa } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const Ja = (() => Promise.resolve(0))(); function Ya(t) { "undefined" == typeof Zone ? Ja.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Xa { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new wa(!1), this.onMicrotaskEmpty = new wa(!1), this.onStable = new wa(!1), this.onError = new wa(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const n = this; n._nesting = 0, n._outer = n._inner = Zone.current, Zone.wtfZoneSpec && (n._inner = n._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (n._inner = n._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (n._inner = n._inner.fork(Zone.longStackTraceZoneSpec)), n.shouldCoalesceEventChangeDetection = e, n.lastRequestAnimationFrameId = -1, n.nativeRequestAnimationFrame = function () { let t = kt.requestAnimationFrame, e = kt.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = !!t.shouldCoalesceEventChangeDetection && t.nativeRequestAnimationFrame && (() => { !function (t) { -1 === t.lastRequestAnimationFrameId && (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(kt, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, rl(t), nl(t) }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), rl(t)) }(t) }); t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0, maybeDelayChangeDetection: e }, onInvokeTask: (n, r, s, i, o, a) => { try { return sl(t), n.invokeTask(s, i, o, a) } finally { e && "eventTask" === i.type && e(), il(t) } }, onInvoke: (e, n, r, s, i, o, a) => { try { return sl(t), e.invoke(r, s, i, o, a) } finally { il(t) } }, onHasTask: (e, n, r, s) => { e.hasTask(r, s), n === r && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, rl(t), nl(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, n, r, s) => (e.handleError(r, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(n) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Xa.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Xa.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, r) { const s = this._inner, i = s.scheduleEventTask("NgZoneEvent: " + r, t, el, tl, tl); try { return s.runTask(i, e, n) } finally { s.cancelTask(i) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } function tl() { } const el = {}; function nl(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++ , t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting-- , !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function rl(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || t.shouldCoalesceEventChangeDetection && -1 !== t.lastRequestAnimationFrameId) } function sl(t) { t._nesting++ , t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function il(t) { t._nesting-- , nl(t) } class ol { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new wa, this.onMicrotaskEmpty = new wa, this.onStable = new wa, this.onError = new wa } run(t, e, n) { return t.apply(e, n) } runGuarded(t, e, n) { return t.apply(e, n) } runOutsideAngular(t) { return t() } runTask(t, e, n, r) { return t.apply(e, n) } } let al = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Xa.assertNotInAngularZone(), Ya(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Ya(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let r = -1; e && e > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== r), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: r, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Xa)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), ll = (() => { class t { constructor() { this._applications = new Map, hl.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return hl.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); class ul { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } let cl, hl = new ul; const dl = new Dt("AllowMultipleToken"); class pl { constructor(t, e) { this.name = t, this.token = e } } function fl(t, e, n = []) { const r = "Platform: " + e, s = new Dt(r); return (e = []) => { let i = gl(); if (!i || i.injector.get(dl, !1)) if (t) t(n.concat(e).concat({ provide: s, useValue: !0 })); else { const t = n.concat(e).concat({ provide: s, useValue: !0 }, { provide: oi, useValue: "platform" }); !function (t) { if (cl && !cl.destroyed && !cl.injector.get(dl, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); cl = t.get(ml); const e = t.get(Ua, null); e && e.forEach(t => t()) }(wi.create({ providers: t, name: r })) } return function (t) { const e = gl(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(s) } } function gl() { return cl && !cl.destroyed ? cl : null } let ml = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t, e) { let n; return n = "noop" === t ? new ol : ("zone.js" === t ? void 0 : t) || new Xa({ enableLongStackTrace: mr(), shouldCoalesceEventChangeDetection: e }), n }(e ? e.ngZone : void 0, e && e.ngZoneEventCoalescing || !1), r = [{ provide: Xa, useValue: n }]; return n.run(() => { const e = wi.create({ providers: r, parent: this.injector, name: t.moduleType.name }), s = t.create(e), i = s.injector.get(hr, null); if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return s.onDestroy(() => vl(this._modules, s)), n.runOutsideAngular(() => n.onError.subscribe({ next: t => { i.handleError(t) } })), function (t, e, n) { try { const r = n(); return $i(r) ? r.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(i, n, () => { const t = s.injector.get(Va); return t.runInitializers(), t.donePromise.then(() => (Eo(s.injector.get(Ha, So) || So), this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(t, e = []) { const n = yl({}, e); return function (t, e, n) { const r = new va(n); return Promise.resolve(r) }(0, 0, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(_l); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${_t(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(Zt(wi)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); function yl(t, e) { return Array.isArray(e) ? e.reduce(yl, t) : Object.assign(Object.assign({}, t), e) } let _l = (() => { class t { constructor(t, e, n, r, s, i) { this._zone = t, this._console = e, this._injector = n, this._exceptionHandler = r, this._componentFactoryResolver = s, this._initStatus = i, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = mr(), this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new _(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), a = new _(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Xa.assertNotInAngularZone(), Ya(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Xa.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = function (...t) { let e = Number.POSITIVE_INFINITY, n = null, r = t[t.length - 1]; return E(r) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof r && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof _ ? t[0] : z(e)(B(t, n)) }(o, a.pipe(t => { return q()((e = J, function (t) { let n; n = "function" == typeof e ? e : function () { return e }; const r = Object.create(t, Q); return r.source = t, r.subjectFactory = n, r })(t)); var e })) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof jo ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const r = n.isBoundToModule ? void 0 : this._injector.get(Jt), s = n.create(wi.NULL, [], e || n.selector, r); s.onDestroy(() => { this._unloadComponent(s) }); const i = s.injector.get(al, null); return i && s.injector.get(ll).registerApplication(s.location.nativeElement, i), this._loadComponent(s), mr() && this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges(); if (this._enforceNoNewChanges) for (let t of this._views) t.checkNoChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; vl(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(Fa, []).concat(this._bootstrapListeners).forEach(e => e(t)) } _unloadComponent(t) { this.detachView(t.hostView), vl(this.components, t) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()) } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Xa), Zt(La), Zt(wi), Zt(hr), Zt(Do), Zt(Va)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); function vl(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class wl { } class bl { } const Cl = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let Sl = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || Cl } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, r] = t.split("#"); return void 0 === r && (r = "default"), n("zn8P")(e).then(t => t[r]).then(t => xl(t, e, r)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, r] = t.split("#"), s = "NgFactory"; return void 0 === r && (r = "default", s = ""), n("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[r + s]).then(t => xl(t, e, r)) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Ka), Zt(bl, 8)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); function xl(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } const El = fl(null, "core", [{ provide: Ma, useValue: "unknown" }, { provide: ml, deps: [wi] }, { provide: ll, deps: [] }, { provide: La, deps: [] }]), Tl = [{ provide: _l, useClass: _l, deps: [Xa, La, wi, hr, Do, Va] }, { provide: fa, deps: [Xa], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: Va, useClass: Va, deps: [[new nt, Pa]] }, { provide: Ka, useClass: Ka, deps: [] }, Na, { provide: na, useFactory: function () { return ia }, deps: [] }, { provide: ra, useFactory: function () { return oa }, deps: [] }, { provide: Ha, useFactory: function (t) { return Eo(t = t || "undefined" != typeof $localize && $localize.locale || So), t }, deps: [[new et(Ha), new nt, new st]] }, { provide: $a, useValue: "USD" }]; let Al = (() => { class t { constructor(t) { } } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t)(Zt(_l)) }, providers: Tl }), t })(); const kl = "http://localhost:15508"; let Ol = null; function Rl() { return Ol } const Il = new Dt("DocumentToken"); let Pl = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ factory: Vl, token: t, providedIn: "platform" }), t })(); function Vl() { return Zt(Nl) } const jl = new Dt("Location Initialized"); let Nl = (() => { class t extends Pl { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = Rl().getLocation(), this._history = Rl().getHistory() } getBaseHrefFromDOM() { return Rl().getBaseHref(this._doc) } onPopState(t) { Rl().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1) } onHashChange(t) { Rl().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { Dl() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { Dl() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Il)) }, t.\u0275prov = lt({ factory: Ul, token: t, providedIn: "platform" }), t })(); function Dl() { return !!window.history.pushState } function Ul() { return new Nl(Zt(Il)) } function Ml(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++ , e.startsWith("/") && n++ , 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function Fl(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function Ll(t) { return t && "?" !== t[0] ? "?" + t : t } let Hl = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ factory: $l, token: t, providedIn: "root" }), t })(); function $l(t) { const e = Zt(Il).location; return new Bl(Zt(Pl), e && e.origin || "") } const zl = new Dt("appBaseHref"); let Bl = (() => { class t extends Hl { constructor(t, e) { if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return Ml(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + Ll(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, r) { const s = this.prepareExternalUrl(n + Ll(r)); this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { const s = this.prepareExternalUrl(n + Ll(r)); this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Pl), Zt(zl, 8)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), ql = (() => { class t extends Hl { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e) } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = Ml(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, r) { let s = this.prepareExternalUrl(n + Ll(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { let s = this.prepareExternalUrl(n + Ll(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Pl), Zt(zl, 8)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), Wl = (() => { class t { constructor(t, e) { this._subject = new wa, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = Fl(Gl(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + Ll(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, Gl(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Ll(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Ll(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(t) { this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) })) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Hl), Zt(Pl)) }, t.normalizeQueryParams = Ll, t.joinWithSlash = Ml, t.stripTrailingSlash = Fl, t.\u0275prov = lt({ factory: Zl, token: t, providedIn: "root" }), t })(); function Zl() { return new Wl(Zt(Hl), Zt(Pl)) } function Gl(t) { return t.replace(/\/index.html$/, "") } var Ql = function (t) { return t[t.Zero = 0] = "Zero", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Few = 3] = "Few", t[t.Many = 4] = "Many", t[t.Other = 5] = "Other", t }({}); class Kl { } let Jl = (() => { class t extends Kl { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (function (t) { return function (t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let n = bo(e); if (n) return n; const r = e.split("-")[0]; if (n = bo(r), n) return n; if ("en" === r) return vo; throw new Error(`Missing locale data for the locale "${t}".`) }(t)[Co.PluralCase] }(e || this.locale)(t)) { case Ql.Zero: return "zero"; case Ql.One: return "one"; case Ql.Two: return "two"; case Ql.Few: return "few"; case Ql.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Ha)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); function Yl(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [r, s] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (r.trim() === e) return decodeURIComponent(s) } return null } class Xl { constructor(t, e, n, r) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let tu = (() => { class t { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { mr() && null != t && "function" != typeof t && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(t)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`), this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${t = n, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, r) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new Xl(null, this._ngForOf, -1, -1), null === r ? void 0 : r), s = new eu(t, n); e.push(s) } else if (null == r) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const s = this._viewContainer.get(n); this._viewContainer.move(s, r); const i = new eu(t, s); e.push(i) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, r = this._viewContainer.length; n < r; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = r, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Di(ua), Di(aa), Di(na)) }, t.\u0275dir = ye({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); class eu { constructor(t, e) { this.record = t, this.view = e } } let nu = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new ru, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { su("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { su("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Di(ua), Di(aa)) }, t.\u0275dir = ye({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class ru { constructor() { this.$implicit = null, this.ngIf = null } } function su(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${_t(e)}'.`) } let iu = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [{ provide: Kl, useClass: Jl }] }), t })(), ou = (() => { class t { } return t.\u0275prov = lt({ token: t, providedIn: "root", factory: () => new au(Zt(Il), window, Zt(hr)) }), t })(); class au { constructor(t, e, n) { this.document = t, this.window = e, this.errorHandler = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.scrollX, this.window.scrollY] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (this.supportsScrolling()) { const e = this.document.getElementById(t) || this.document.getElementsByName(t)[0]; e && this.scrollToElement(e) } } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, r = e.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(n - s[0], r - s[1]) } supportScrollRestoration() { try { if (!this.window || !this.window.scrollTo) return !1; const t = lu(this.window.history) || lu(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window.scrollTo } catch (t) { return !1 } } } function lu(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class uu extends class extends class { }{ constructor() { super() } supportsDOMEvents() { return !0 } }{ static makeCurrent() { var t; t = new uu, Ol || (Ol = t) } getProperty(t, e) { return t[e] } log(t) { window.console && window.console.log && window.console.log(t) } logGroup(t) { window.console && window.console.group && window.console.group(t) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { return t.parentNode && t.parentNode.removeChild(t), t } getValue(t) { return t.value } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(t) { const e = hu || (hu = document.querySelector("base"), hu) ? hu.getAttribute("href") : null; return null == e ? null : (n = e, cu || (cu = document.createElement("a")), cu.setAttribute("href", n), "/" === cu.pathname.charAt(0) ? cu.pathname : "/" + cu.pathname); var n } resetBaseElement() { hu = null } getUserAgent() { return window.navigator.userAgent } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(t) { return Yl(document.cookie, t) } } let cu, hu = null; const du = new Dt("TRANSITION_ID"), pu = [{ provide: Pa, useFactory: function (t, e, n) { return () => { n.get(Va).donePromise.then(() => { const n = Rl(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [du, Il, wi], multi: !0 }]; class fu { static init() { var t; t = new fu, hl = t } addToWindow(t) { kt.getAngularTestability = (e, n = !0) => { const r = t.findTestabilityInTree(e, n); if (null == r) throw new Error("Could not find testability for element."); return r }, kt.getAllAngularTestabilities = () => t.getAllTestabilities(), kt.getAllAngularRootElements = () => t.getAllRootElements(), kt.frameworkStabilizers || (kt.frameworkStabilizers = []), kt.frameworkStabilizers.push(t => { const e = kt.getAllAngularTestabilities(); let n = e.length, r = !1; const s = function (e) { r = r || e, n-- , 0 == n && t(r) }; e.forEach((function (t) { t.whenStable(s) })) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : n ? Rl().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } const gu = new Dt("EventManagerPlugins"); let mu = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let r = 0; r < n.length; r++) { const e = n[r]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error("No event manager plugin found for event " + t) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(gu), Zt(Xa)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); class yu { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const r = Rl().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, n) } } let _u = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), vu = (() => { class t extends _u { constructor(t) { super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head) } _addStylesToHost(t, e) { t.forEach(t => { const n = this._doc.createElement("style"); n.textContent = t, this._styleNodes.add(e.appendChild(n)) }) } addHost(t) { this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t) } removeHost(t) { this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach(e => this._addStylesToHost(t, e)) } ngOnDestroy() { this._styleNodes.forEach(t => Rl().remove(t)) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Il)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const wu = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, bu = /%COMP%/g; function Cu(t, e, n) { for (let r = 0; r < e.length; r++) { let s = e[r]; Array.isArray(s) ? Cu(t, s, n) : (s = s.replace(bu, t), n.push(s)) } return n } function Su(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let xu = (() => { class t { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Eu(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case ae.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new Tu(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case ae.Native: case ae.ShadowDom: return new Au(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = Cu(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(Zt(mu), Zt(vu), Zt(ja)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); class Eu { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(wu[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, r) { if (r) { e = r + ":" + e; const s = wu[r]; s ? t.setAttributeNS(s, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const r = wu[n]; r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, r) { r & Lo.DashCase ? t.style.setProperty(e, n, r & Lo.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & Lo.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, Su(n)) : this.eventManager.addEventListener(t, e, Su(n)) } } class Tu extends Eu { constructor(t, e, n, r) { super(t), this.component = n; const s = Cu(r + "-" + n.id, n.styles, []); e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(bu, r + "-" + n.id), this.hostAttr = "_nghost-%COMP%".replace(bu, r + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class Au extends Eu { constructor(t, e, n, r) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.component = r, this.shadowRoot = r.encapsulation === ae.ShadowDom ? n.attachShadow({ mode: "open" }) : n.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot); const s = Cu(r.id, r.styles, []); for (let i = 0; i < s.length; i++) { const t = document.createElement("style"); t.textContent = s[i], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let ku = (() => { class t extends yu { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, n) { return t.addEventListener(e, n, !1), () => this.removeEventListener(t, e, n) } removeEventListener(t, e, n) { return t.removeEventListener(e, n) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Il)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const Ou = ["alt", "control", "meta", "shift"], Ru = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Iu = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, Pu = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let Vu = (() => { class t extends yu { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, r) { const s = t.parseEventName(n), i = t.eventCallback(s.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Rl().onAndCancel(e, s.domEventName, i)) } static parseEventName(e) { const n = e.toLowerCase().split("."), r = n.shift(); if (0 === n.length || "keydown" !== r && "keyup" !== r) return null; const s = t._normalizeKey(n.pop()); let i = ""; if (Ou.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), i += t + ".") }), i += s, 0 != n.length || 0 === s.length) return null; const o = {}; return o.domEventName = r, o.fullKey = i, o } static getEventFullKey(t) { let e = "", n = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && Iu.hasOwnProperty(e) && (e = Iu[e])) } return Ru[e] || e }(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), Ou.forEach(r => { r != n && (0, Pu[r])(t) && (e += r + ".") }), e += n, e } static eventCallback(e, n, r) { return s => { t.getEventFullKey(s) === e && r.runGuarded(() => n(s)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Il)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const ju = fl(El, "browser", [{ provide: Ma, useValue: "browser" }, { provide: Ua, useValue: function () { uu.makeCurrent(), fu.init() }, multi: !0 }, { provide: Il, useFactory: function () { return function (t) { He = t }(document), document }, deps: [] }]), Nu = [[], { provide: oi, useValue: "root" }, { provide: hr, useFactory: function () { return new hr }, deps: [] }, { provide: gu, useClass: ku, multi: !0, deps: [Il, Xa, Ma] }, { provide: gu, useClass: Vu, multi: !0, deps: [Il] }, [], { provide: xu, useClass: xu, deps: [mu, vu, ja] }, { provide: Fo, useExisting: xu }, { provide: _u, useExisting: vu }, { provide: vu, useClass: vu, deps: [Il] }, { provide: al, useClass: al, deps: [Xa] }, { provide: mu, useClass: mu, deps: [gu, Xa] }, []]; let Du = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: ja, useValue: e.appId }, { provide: du, useExisting: ja }, pu] } } } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t)(Zt(t, 12)) }, providers: Nu, imports: [iu, Al] }), t })(); function Uu(...t) { let e = t[t.length - 1]; return E(e) ? (t.pop(), N(t, e)) : B(t) } "undefined" != typeof window && window; class Mu extends S { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new w; return this._value } next(t) { super.next(this._value = t) } } class Fu extends f { notifyNext(t, e, n, r, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } class Lu extends f { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } function Hu(t, e, n, r, s = new Lu(t, n, r)) { if (!s.closed) return e instanceof _ ? e.subscribe(s) : j(e)(s) } const $u = {}; class zu { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new Bu(t, this.resultSelector)) } } class Bu extends Fu { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push($u), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++)this.add(Hu(this, t[n], void 0, n)) } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n) { const r = this.values, s = this.toRespond ? r[n] === $u ? --this.toRespond : this.toRespond : 0; r[n] = e, 0 === s && (this.resultSelector ? this._tryResultSelector(r) : this.destination.next(r.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const qu = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(), Wu = new _(t => t.complete()); function Zu(t) { return t ? function (t) { return new _(e => t.schedule(() => e.complete())) }(t) : Wu } function Gu(t) { return new _(e => { let n; try { n = t() } catch (r) { return void e.error(r) } return (n ? D(n) : Zu()).subscribe(e) }) } function Qu() { return z(1) } function Ku(t, e) { return function (n) { return n.lift(new Ju(t, e)) } } class Ju { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new Yu(t, this.predicate, this.thisArg)) } } class Yu extends f { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } const Xu = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })(); function tc(t) { return function (e) { return 0 === t ? Zu() : e.lift(new ec(t)) } } class ec { constructor(t) { if (this.total = t, this.total < 0) throw new Xu } call(t, e) { return e.subscribe(new nc(t, this.total)) } } class nc extends f { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, r = this.count++; e.length < n ? e.push(t) : e[r % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, r = this.ring; for (let s = 0; s < n; s++) { const s = e++ % n; t.next(r[s]) } } t.complete() } } function rc(t = oc) { return e => e.lift(new sc(t)) } class sc { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new ic(t, this.errorFactory)) } } class ic extends f { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function oc() { return new qu } function ac(t = null) { return e => e.lift(new lc(t)) } class lc { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new uc(t, this.defaultValue)) } } class uc extends f { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function cc(t, e) { return "function" == typeof e ? n => n.pipe(cc((n, r) => D(t(n, r)).pipe(T((t, s) => e(n, t, r, s))))) : e => e.lift(new hc(t)) } class hc { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new dc(t, this.project)) } } class dc extends M { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this._innerSub(e) } _innerSub(t) { const e = this.innerSubscription; e && e.unsubscribe(); const n = new U(this), r = this.destination; r.add(n), this.innerSubscription = F(t, n), this.innerSubscription !== n && r.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = void 0 } notifyComplete() { this.innerSubscription = void 0, this.isStopped && super._complete() } notifyNext(t) { this.destination.next(t) } } function pc(t) { return e => 0 === t ? Zu() : e.lift(new fc(t)) } class fc { constructor(t) { if (this.total = t, this.total < 0) throw new Xu } call(t, e) { return e.subscribe(new gc(t, this.total)) } } class gc extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } function mc(...t) { return Qu()(Uu(...t)) } class yc { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new _c(t, this.accumulator, this.seed, this.hasSeed)) } } class _c extends f { constructor(t, e, n, r) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = r, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (r) { this.destination.error(r) } this.seed = n, this.destination.next(n) } } function vc(t) { return function (e) { const n = new wc(t), r = e.lift(n); return n.caught = r } } class wc { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new bc(t, this.selector, this.caught)) } } class bc extends M { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const r = new U(this); this.add(r); const s = F(n, r); s !== r && this.add(s) } } } function Cc(t, e) { return L(t, e, 1) } function Sc(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? Ku((e, n) => t(e, n, r)) : y, pc(1), n ? ac(e) : rc(() => new qu)) } function xc() { } function Ec(t, e, n) { return function (r) { return r.lift(new Tc(t, e, n)) } } class Tc { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new Ac(t, this.nextOrObserver, this.error, this.complete)) } } class Ac extends f { constructor(t, e, n, s) { super(t), this._tapNext = xc, this._tapError = xc, this._tapComplete = xc, this._tapError = n || xc, this._tapComplete = s || xc, r(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || xc, this._tapError = e.error || xc, this._tapComplete = e.complete || xc) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } class kc { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new Oc(t, this.callback)) } } class Oc extends f { constructor(t, e) { super(t), this.add(new h(e)) } } class Rc { constructor(t, e) { this.id = t, this.url = e } } class Ic extends Rc { constructor(t, e, n = "imperative", r = null) { super(t, e), this.navigationTrigger = n, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Pc extends Rc { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Vc extends Rc { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class jc extends Rc { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class Nc extends Rc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Dc extends Rc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Uc extends Rc { constructor(t, e, n, r, s) { super(t, e), this.urlAfterRedirects = n, this.state = r, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class Mc extends Rc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Fc extends Rc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Lc { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Hc { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class $c { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class zc { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Bc { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class qc { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Wc { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const Zc = "primary"; class Gc { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function Qc(t) { return new Gc(t) } function Kc(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function Jc(t, e, n) { const r = n.path.split("/"); if (r.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || r.length < t.length)) return null; const s = {}; for (let i = 0; i < r.length; i++) { const e = r[i], n = t[i]; if (e.startsWith(":")) s[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, r.length), posParams: s } } function Yc(t, e) { const n = Object.keys(t), r = Object.keys(e); if (!n || !r || n.length != r.length) return !1; let s; for (let i = 0; i < n.length; i++)if (s = n[i], !Xc(t[s], e[s])) return !1; return !0 } function Xc(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const n = [...t].sort(), r = [...e].sort(); return n.every((t, e) => r[e] === t) } return t === e } function th(t) { return Array.prototype.concat.apply([], t) } function eh(t) { return t.length > 0 ? t[t.length - 1] : null } function nh(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function rh(t) { return zi(t) ? t : $i(t) ? D(Promise.resolve(t)) : Uu(t) } function sh(t, e, n) { return n ? function (t, e) { return Yc(t, e) }(t.queryParams, e.queryParams) && function t(e, n) { if (!lh(e.segments, n.segments)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const r in n.children) { if (!e.children[r]) return !1; if (!t(e.children[r], n.children[r])) return !1 } return !0 }(t.root, e.root) : function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => Xc(t[n], e[n])) }(t.queryParams, e.queryParams) && function t(e, n) { return function e(n, r, s) { if (n.segments.length > s.length) return !!lh(n.segments.slice(0, s.length), s) && !r.hasChildren(); if (n.segments.length === s.length) { if (!lh(n.segments, s)) return !1; for (const e in r.children) { if (!n.children[e]) return !1; if (!t(n.children[e], r.children[e])) return !1 } return !0 } { const t = s.slice(0, n.segments.length), i = s.slice(n.segments.length); return !!lh(n.segments, t) && !!n.children.primary && e(n.children.primary, r, i) } }(e, n, n.segments) }(t.root, e.root) } class ih { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Qc(this.queryParams)), this._queryParamMap } toString() { return dh.serialize(this) } } class oh { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, nh(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return ph(this) } } class ah { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Qc(this.parameters)), this._parameterMap } toString() { return vh(this) } } function lh(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } function uh(t, e) { let n = []; return nh(t.children, (t, r) => { r === Zc && (n = n.concat(e(t, r))) }), nh(t.children, (t, r) => { r !== Zc && (n = n.concat(e(t, r))) }), n } class ch { } class hh { parse(t) { const e = new xh(t); return new ih(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { return `${"/" + function t(e, n) { if (!e.hasChildren()) return ph(e); if (n) { const n = e.children.primary ? t(e.children.primary, !1) : "", r = []; return nh(e.children, (e, n) => { n !== Zc && r.push(`${n}:${t(e, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = uh(e, (n, r) => r === Zc ? [t(e.children.primary, !1)] : [`${r}:${t(n, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children.primary ? `${ph(e)}/${n[0]}` : `${ph(e)}/(${n.join("//")})` } }(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${gh(e)}=${gh(t)}`).join("&") : `${gh(e)}=${gh(n)}` }); return e.length ? "?" + e.join("&") : "" }(t.queryParams)}${"string" == typeof t.fragment ? "#" + encodeURI(t.fragment) : ""}` } } const dh = new hh; function ph(t) { return t.segments.map(t => vh(t)).join("/") } function fh(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function gh(t) { return fh(t).replace(/%3B/gi, ";") } function mh(t) { return fh(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function yh(t) { return decodeURIComponent(t) } function _h(t) { return yh(t.replace(/\+/g, "%20")) } function vh(t) { return `${mh(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${mh(t)}=${mh(e[t])}`).join("")}`; var e } const wh = /^[^\/()?;=#]+/; function bh(t) { const e = t.match(wh); return e ? e[0] : "" } const Ch = /^[^=?&#]+/, Sh = /^[^?&#]+/; class xh { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new oh([], {}) : new oh([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new oh(t, e)), n } parseSegment() { const t = bh(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new ah(yh(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = bh(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = bh(this.remaining); t && (n = t, this.capture(n)) } t[yh(e)] = yh(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(Ch); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(Sh); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const r = _h(e), s = _h(n); if (t.hasOwnProperty(r)) { let e = t[r]; Array.isArray(e) || (e = [e], t[r] = e), e.push(s) } else t[r] = s } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = bh(this.remaining), r = this.remaining[n.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let s = void 0; n.indexOf(":") > -1 ? (s = n.substr(0, n.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = Zc); const i = this.parseChildren(); e[s] = 1 === Object.keys(i).length ? i.primary : new oh([], i), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Eh { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = Th(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = Th(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Ah(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return Ah(t, this._root).map(t => t.value) } } function Th(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = Th(t, n); if (e) return e } return null } function Ah(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const r = Ah(t, n); if (r.length) return r.unshift(e), r } return [] } class kh { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function Oh(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class Rh extends Eh { constructor(t, e) { super(t), this.snapshot = e, Dh(this, t) } toString() { return this.snapshot.toString() } } function Ih(t, e) { const n = function (t, e) { const n = new jh([], {}, {}, "", {}, Zc, e, null, t.root, -1, {}); return new Nh("", new kh(n, [])) }(t, e), r = new Mu([new ah("", {})]), s = new Mu({}), i = new Mu({}), o = new Mu({}), a = new Mu(""), l = new Ph(r, s, o, a, i, Zc, e, n.root); return l.snapshot = n.root, new Rh(new kh(l, []), n) } class Ph { constructor(t, e, n, r, s, i, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(T(t => Qc(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(T(t => Qc(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function Vh(t, e = "emptyOnly") { const n = t.pathFromRoot; let r = 0; if ("always" !== e) for (r = n.length - 1; r >= 1;) { const t = n[r], e = n[r - 1]; if (t.routeConfig && "" === t.routeConfig.path) r--; else { if (e.component) break; r-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class jh { constructor(t, e, n, r, s, i, o, a, l, u, c) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = u, this._resolve = c } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Qc(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Qc(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Nh extends Eh { constructor(t, e) { super(e), this.url = t, Dh(this, e) } toString() { return Uh(this._root) } } function Dh(t, e) { e.value._routerState = t, e.children.forEach(e => Dh(t, e)) } function Uh(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Uh).join(", ")} } ` : ""; return `${t.value}${e}` } function Mh(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, Yc(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), Yc(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!Yc(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), Yc(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function Fh(t, e) { var n, r; return Yc(t.params, e.params) && lh(n = t.url, r = e.url) && n.every((t, e) => Yc(t.parameters, r[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || Fh(t.parent, e.parent)) } function Lh(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Hh(t) { return "object" == typeof t && null != t && t.outlets } function $h(t, e, n, r, s) { let i = {}; return r && nh(r, (t, e) => { i[e] = Array.isArray(t) ? t.map(t => "" + t) : "" + t }), new ih(n.root === t ? e : function t(e, n, r) { const s = {}; return nh(e.children, (e, i) => { s[i] = e === n ? r : t(e, n, r) }), new oh(e.segments, s) }(n.root, t, e), i, s) } class zh { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && Lh(n[0])) throw new Error("Root segment cannot have matrix parameters"); const r = n.find(Hh); if (r && r !== eh(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Bh { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function qh(t, e, n) { if (t || (t = new oh([], {})), 0 === t.segments.length && t.hasChildren()) return Wh(t, e, n); const r = function (t, e, n) { let r = 0, s = e; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < t.segments.length;) { if (r >= n.length) return i; const e = t.segments[s], o = n[r]; if (Hh(o)) break; const a = "" + o, l = r < n.length - 1 ? n[r + 1] : null; if (s > 0 && void 0 === a) break; if (a && l && "object" == typeof l && void 0 === l.outlets) { if (!Kh(a, l, e)) return i; r += 2 } else { if (!Kh(a, {}, e)) return i; r++ } s++ } return { match: !0, pathIndex: s, commandIndex: r } }(t, e, n), s = n.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) { const e = new oh(t.segments.slice(0, r.pathIndex), {}); return e.children.primary = new oh(t.segments.slice(r.pathIndex), t.children), Wh(e, 0, s) } return r.match && 0 === s.length ? new oh(t.segments, {}) : r.match && !t.hasChildren() ? Zh(t, e, n) : r.match ? Wh(t, 0, s) : Zh(t, e, n) } function Wh(t, e, n) { if (0 === n.length) return new oh(t.segments, {}); { const r = function (t) { return Hh(t[0]) ? t[0].outlets : { [Zc]: t } }(n), s = {}; return nh(r, (n, r) => { null !== n && (s[r] = qh(t.children[r], e, n)) }), nh(t.children, (t, e) => { void 0 === r[e] && (s[e] = t) }), new oh(t.segments, s) } } function Zh(t, e, n) { const r = t.segments.slice(0, e); let s = 0; for (; s < n.length;) { const i = n[s]; if (Hh(i)) { const t = Gh(i.outlets); return new oh(r, t) } if (0 === s && Lh(n[0])) { r.push(new ah(t.segments[e].path, n[0])), s++; continue } const o = Hh(i) ? i.outlets.primary : "" + i, a = s < n.length - 1 ? n[s + 1] : null; o && a && Lh(a) ? (r.push(new ah(o, Qh(a))), s += 2) : (r.push(new ah(o, {})), s++) } return new oh(r, {}) } function Gh(t) { const e = {}; return nh(t, (t, n) => { null !== t && (e[n] = Zh(new oh([], {}), 0, t)) }), e } function Qh(t) { const e = {}; return nh(t, (t, n) => e[n] = "" + t), e } function Kh(t, e, n) { return t == n.path && Yc(e, n.parameters) } class Jh { constructor(t, e, n, r) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = r } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), Mh(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const r = Oh(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, r[e], n), delete r[e] }), nh(r, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (r === s) if (r.component) { const s = n.getContext(r.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, n); else s && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), r = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: r }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet); if (n) { const r = Oh(t), s = t.value.component ? n.children : e; nh(r, (t, e) => this.deactivateRouteAndItsChildren(t, s)), n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated()) } } activateChildRoutes(t, e, n) { const r = Oh(e); t.children.forEach(t => { this.activateRoutes(t, r[t.value.outlet], n), this.forwardEvent(new qc(t.value.snapshot)) }), t.children.length && this.forwardEvent(new zc(t.value.snapshot)) } activateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (Mh(r), r === s) if (r.component) { const s = n.getOrCreateContext(r.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, n); else if (r.component) { const e = n.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const t = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), Yh(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(r.snapshot), s = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = r, e.resolver = s, e.outlet && e.outlet.activateWith(r, s), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function Yh(t) { Mh(t.value), t.children.forEach(Yh) } class Xh { constructor(t, e) { this.routes = t, this.module = e } } function td(t) { return "function" == typeof t } function ed(t) { return t instanceof ih } const nd = Symbol("INITIAL_VALUE"); function rd() { return cc(t => function (...t) { let e = void 0, n = void 0; return E(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && l(t[0]) && (t = t[0]), B(t, n).lift(new zu(e)) }(...t.map(t => t.pipe(pc(1), function (...t) { const e = t[t.length - 1]; return E(e) ? (t.pop(), n => mc(t, n, e)) : e => mc(t, e) }(nd)))).pipe(function (t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new yc(t, e, n)) } }((t, e) => { let n = !1; return e.reduce((t, r, s) => { if (t !== nd) return t; if (r === nd && (n = !0), !n) { if (!1 === r) return r; if (s === e.length - 1 || ed(r)) return r } return t }, t) }, nd), Ku(t => t !== nd), T(t => ed(t) ? t : !0 === t), pc(1))) } class sd { constructor(t) { this.segmentGroup = t || null } } class id { constructor(t) { this.urlTree = t } } function od(t) { return new _(e => e.error(new sd(t))) } function ad(t) { return new _(e => e.error(new id(t))) } function ld(t) { return new _(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class ud { constructor(t, e, n, r, s) { this.configLoader = e, this.urlSerializer = n, this.urlTree = r, this.config = s, this.allowRedirects = !0, this.ngModule = t.get(Jt) } apply() { return this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, Zc).pipe(T(t => this.createUrlTree(t, this.urlTree.queryParams, this.urlTree.fragment))).pipe(vc(t => { if (t instanceof id) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof sd) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, Zc).pipe(T(e => this.createUrlTree(e, t.queryParams, t.fragment))).pipe(vc(t => { if (t instanceof sd) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const r = t.segments.length > 0 ? new oh([], { [Zc]: t }) : t; return new ih(r, e, n) } expandSegmentGroup(t, e, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(T(t => new oh([], t))) : this.expandSegment(t, n, e, n.segments, r, !0) } expandChildren(t, e, n) { return function (t, e) { if (0 === Object.keys(t).length) return Uu({}); const n = [], r = [], s = {}; return nh(t, (t, i) => { const o = e(i, t).pipe(T(t => s[i] = t)); i === Zc ? n.push(o) : r.push(o) }), Uu.apply(null, n.concat(r)).pipe(Qu(), function (t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? Ku((e, n) => t(e, n, r)) : y, tc(1), n ? ac(e) : rc(() => new qu)) }(), T(() => s)) }(n.children, (n, r) => this.expandSegmentGroup(t, e, r, n)) } expandSegment(t, e, n, r, s, i) { return Uu(...n).pipe(Cc(o => this.expandSegmentAgainstRoute(t, e, n, o, r, s, i).pipe(vc(t => { if (t instanceof sd) return Uu(null); throw t }))), Sc(t => !!t), vc((t, n) => { if (t instanceof qu || "EmptyError" === t.name) { if (this.noLeftoversInUrl(e, r, s)) return Uu(new oh([], {})); throw new sd(e) } throw t })) } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } expandSegmentAgainstRoute(t, e, n, r, s, i, o) { return pd(r) !== i ? od(e) : void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, e, r, s) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) : od(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, i) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, r) { const s = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? ad(s) : this.lineralizeSegments(n, s).pipe(L(n => { const s = new oh(n, {}); return this.expandSegment(t, s, e, n, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: u } = cd(e, r, s); if (!o) return od(e); const c = this.applyRedirectCommands(a, r.redirectTo, u); return r.redirectTo.startsWith("/") ? ad(c) : this.lineralizeSegments(r, c).pipe(L(r => this.expandSegment(t, e, n, r.concat(s.slice(l)), i, !1))) } matchSegmentAgainstRoute(t, e, n, r) { if ("**" === n.path) return n.loadChildren ? this.configLoader.load(t.injector, n).pipe(T(t => (n._loadedConfig = t, new oh(r, {})))) : Uu(new oh(r, {})); const { matched: s, consumedSegments: i, lastChild: o } = cd(e, n, r); if (!s) return od(e); const a = r.slice(o); return this.getChildConfig(t, n, r).pipe(L(t => { const n = t.module, r = t.routes, { segmentGroup: s, slicedSegments: o } = function (t, e, n, r) { return n.length > 0 && function (t, e, n) { return n.some(n => dd(t, e, n) && pd(n) !== Zc) }(t, n, r) ? { segmentGroup: hd(new oh(e, function (t, e) { const n = {}; n.primary = e; for (const r of t) "" === r.path && pd(r) !== Zc && (n[pd(r)] = new oh([], {})); return n }(r, new oh(n, t.children)))), slicedSegments: [] } : 0 === n.length && function (t, e, n) { return n.some(n => dd(t, e, n)) }(t, n, r) ? { segmentGroup: hd(new oh(t.segments, function (t, e, n, r) { const s = {}; for (const i of n) dd(t, e, i) && !r[pd(i)] && (s[pd(i)] = new oh([], {})); return Object.assign(Object.assign({}, r), s) }(t, n, r, t.children))), slicedSegments: n } : { segmentGroup: t, slicedSegments: n } }(e, i, a, r); return 0 === o.length && s.hasChildren() ? this.expandChildren(n, r, s).pipe(T(t => new oh(i, t))) : 0 === r.length && 0 === o.length ? Uu(new oh(i, {})) : this.expandSegment(n, s, r, o, Zc, !0).pipe(T(t => new oh(i.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? Uu(new Xh(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? Uu(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, n).pipe(L(n => n ? this.configLoader.load(t.injector, e).pipe(T(t => (e._loadedConfig = t, t))) : function (t) { return new _(e => e.error(Kc(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : Uu(new Xh([], t)) } runCanLoadGuards(t, e, n) { const r = e.canLoad; return r && 0 !== r.length ? Uu(r.map(r => { const s = t.get(r); let i; if (function (t) { return t && td(t.canLoad) }(s)) i = s.canLoad(e, n); else { if (!td(s)) throw new Error("Invalid CanLoad guard"); i = s(e, n) } return rh(i) })).pipe(rd(), Ec(t => { if (!ed(t)) return; const e = Kc(`Redirecting to "${this.urlSerializer.serialize(t)}"`); throw e.url = t, e }), T(t => !0 === t)) : Uu(!0) } lineralizeSegments(t, e) { let n = [], r = e.root; for (; ;) { if (n = n.concat(r.segments), 0 === r.numberOfChildren) return Uu(n); if (r.numberOfChildren > 1 || !r.children.primary) return ld(t.redirectTo); r = r.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, r) { const s = this.createSegmentGroup(t, e.root, n, r); return new ih(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return nh(t, (t, r) => { if ("string" == typeof t && t.startsWith(":")) { const s = t.substring(1); n[r] = e[s] } else n[r] = t }), n } createSegmentGroup(t, e, n, r) { const s = this.createSegments(t, e.segments, n, r); let i = {}; return nh(e.children, (e, s) => { i[s] = this.createSegmentGroup(t, e, n, r) }), new oh(s, i) } createSegments(t, e, n, r) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, r) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const r = n[e.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return r } findOrReturn(t, e) { let n = 0; for (const r of e) { if (r.path === t.path) return e.splice(n), r; n++ } return t } } function cd(t, e, n) { if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } : { matched: !0, consumedSegments: [], lastChild: 0, positionalParamSegments: {} }; const r = (e.matcher || Jc)(n, t, e); return r ? { matched: !0, consumedSegments: r.consumed, lastChild: r.consumed.length, positionalParamSegments: r.posParams } : { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } } function hd(t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new oh(t.segments.concat(e.segments), e.children) } return t } function dd(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 !== n.redirectTo } function pd(t) { return t.outlet || Zc } class fd { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class gd { constructor(t, e) { this.component = t, this.route = e } } function md(t, e, n) { const r = t._root; return function t(e, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = Oh(n); return e.children.forEach(e => { !function (e, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = e.value, a = n ? n.value : null, l = r ? r.getContext(e.value.outlet) : null; if (a && o.routeConfig === a.routeConfig) { const u = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !lh(t.url, e.url); case "pathParamsOrQueryParamsChange": return !lh(t.url, e.url) || !Yc(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Fh(t, e) || !Yc(t.queryParams, e.queryParams); case "paramsChange": default: return !Fh(t, e) } }(a, o, o.routeConfig.runGuardsAndResolvers); u ? i.canActivateChecks.push(new fd(s)) : (o.data = a.data, o._resolvedData = a._resolvedData), t(e, n, o.component ? l ? l.children : null : r, s, i), u && l && l.outlet && l.outlet.isActivated && i.canDeactivateChecks.push(new gd(l.outlet.component, a)) } else a && _d(n, l, i), i.canActivateChecks.push(new fd(s)), t(e, null, o.component ? l ? l.children : null : r, s, i) }(e, o[e.value.outlet], r, s.concat([e.value]), i), delete o[e.value.outlet] }), nh(o, (t, e) => _d(t, r.getContext(e), i)), i }(r, e ? e._root : null, n, [r.value]) } function yd(t, e, n) { const r = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (r ? r.module.injector : n).get(t) } function _d(t, e, n) { const r = Oh(t), s = t.value; nh(r, (t, r) => { _d(t, s.component ? e ? e.children.getContext(r) : null : e, n) }), n.canDeactivateChecks.push(new gd(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s)) } function vd(t, e) { return null !== t && e && e(new Bc(t)), Uu(!0) } function wd(t, e) { return null !== t && e && e(new $c(t)), Uu(!0) } function bd(t, e, n) { const r = e.routeConfig ? e.routeConfig.canActivate : null; return r && 0 !== r.length ? Uu(r.map(r => Gu(() => { const s = yd(r, e, n); let i; if (function (t) { return t && td(t.canActivate) }(s)) i = rh(s.canActivate(e, t)); else { if (!td(s)) throw new Error("Invalid CanActivate guard"); i = rh(s(e, t)) } return i.pipe(Sc()) }))).pipe(rd()) : Uu(!0) } function Cd(t, e, n) { const r = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => Gu(() => Uu(e.guards.map(s => { const i = yd(s, e.node, n); let o; if (function (t) { return t && td(t.canActivateChild) }(i)) o = rh(i.canActivateChild(r, t)); else { if (!td(i)) throw new Error("Invalid CanActivateChild guard"); o = rh(i(r, t)) } return o.pipe(Sc()) })).pipe(rd()))); return Uu(s).pipe(rd()) } class Sd { } class xd { constructor(t, e, n, r, s, i) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = r, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = i } recognize() { try { const t = Ad(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, Zc), n = new jh([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, Zc, this.rootComponentType, null, this.urlTree.root, -1, {}), r = new kh(n, e), s = new Nh(this.url, r); return this.inheritParamsAndData(s._root), Uu(s) } catch (t) { return new _(e => e.error(t)) } } inheritParamsAndData(t) { const e = t.value, n = Vh(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = uh(e, (e, n) => this.processSegmentGroup(t, e, n)); return function (t) { const e = {}; t.forEach(t => { const n = e[t.value.outlet]; if (n) { const e = n.url.map(t => t.toString()).join("/"), r = t.value.url.map(t => t.toString()).join("/"); throw new Error(`Two segments cannot have the same outlet name: '${e}' and '${r}'.`) } e[t.value.outlet] = t.value }) }(n), n.sort((t, e) => t.value.outlet === Zc ? -1 : e.value.outlet === Zc ? 1 : t.value.outlet.localeCompare(e.value.outlet)), n } processSegment(t, e, n, r) { for (const i of t) try { return this.processSegmentAgainstRoute(i, e, n, r) } catch (s) { if (!(s instanceof Sd)) throw s } if (this.noLeftoversInUrl(e, n, r)) return []; throw new Sd } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } processSegmentAgainstRoute(t, e, n, r) { if (t.redirectTo) throw new Sd; if ((t.outlet || Zc) !== r) throw new Sd; let s, i = [], o = []; if ("**" === t.path) { const i = n.length > 0 ? eh(n).parameters : {}; s = new jh(n, i, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Rd(t), r, t.component, t, Ed(e), Td(e) + n.length, Id(t)) } else { const a = function (t, e, n) { if ("" === e.path) { if ("full" === e.pathMatch && (t.hasChildren() || n.length > 0)) throw new Sd; return { consumedSegments: [], lastChild: 0, parameters: {} } } const r = (e.matcher || Jc)(n, t, e); if (!r) throw new Sd; const s = {}; nh(r.posParams, (t, e) => { s[e] = t.path }); const i = r.consumed.length > 0 ? Object.assign(Object.assign({}, s), r.consumed[r.consumed.length - 1].parameters) : s; return { consumedSegments: r.consumed, lastChild: r.consumed.length, parameters: i } }(e, t, n); i = a.consumedSegments, o = n.slice(a.lastChild), s = new jh(i, a.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Rd(t), r, t.component, t, Ed(e), Td(e) + i.length, Id(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: u } = Ad(e, i, o, a, this.relativeLinkResolution); if (0 === u.length && l.hasChildren()) { const t = this.processChildren(a, l); return [new kh(s, t)] } if (0 === a.length && 0 === u.length) return [new kh(s, [])]; const c = this.processSegment(a, l, u, Zc); return [new kh(s, c)] } } function Ed(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function Td(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function Ad(t, e, n, r, s) { if (n.length > 0 && function (t, e, n) { return n.some(n => kd(t, e, n) && Od(n) !== Zc) }(t, n, r)) { const s = new oh(e, function (t, e, n, r) { const s = {}; s.primary = r, r._sourceSegment = t, r._segmentIndexShift = e.length; for (const i of n) if ("" === i.path && Od(i) !== Zc) { const n = new oh([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, s[Od(i)] = n } return s }(t, e, r, new oh(n, t.children))); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => kd(t, e, n)) }(t, n, r)) { const i = new oh(t.segments, function (t, e, n, r, s, i) { const o = {}; for (const a of r) if (kd(t, n, a) && !s[Od(a)]) { const n = new oh([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === i ? t.segments.length : e.length, o[Od(a)] = n } return Object.assign(Object.assign({}, s), o) }(t, e, n, r, t.children, s)); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } const i = new oh(t.segments, t.children); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } function kd(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 === n.redirectTo } function Od(t) { return t.outlet || Zc } function Rd(t) { return t.data || {} } function Id(t) { return t.resolve || {} } function Pd(t) { return function (e) { return e.pipe(cc(e => { const n = t(e); return n ? D(n).pipe(T(() => e)) : D([e]) })) } } class Vd extends class { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } let jd = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = he({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && Hi(0, "router-outlet") }, directives: function () { return [Kd] }, encapsulation: 2 }), t })(); function Nd(t, e = "") { for (let n = 0; n < t.length; n++) { const r = t[n]; Dd(r, Ud(e, r)) } } function Dd(t, e) { if (!t) throw new Error(`\n      Invalid configuration of route '${e}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `); if (Array.isArray(t)) throw new Error(`Invalid configuration of route '${e}': Array cannot be specified`); if (!t.component && !t.children && !t.loadChildren && t.outlet && t.outlet !== Zc) throw new Error(`Invalid configuration of route '${e}': a componentless route without children or loadChildren cannot have a named outlet set`); if (t.redirectTo && t.children) throw new Error(`Invalid configuration of route '${e}': redirectTo and children cannot be used together`); if (t.redirectTo && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': redirectTo and loadChildren cannot be used together`); if (t.children && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': children and loadChildren cannot be used together`); if (t.redirectTo && t.component) throw new Error(`Invalid configuration of route '${e}': redirectTo and component cannot be used together`); if (t.path && t.matcher) throw new Error(`Invalid configuration of route '${e}': path and matcher cannot be used together`); if (void 0 === t.redirectTo && !t.component && !t.children && !t.loadChildren) throw new Error(`Invalid configuration of route '${e}'. One of the following must be provided: component, redirectTo, children or loadChildren`); if (void 0 === t.path && void 0 === t.matcher) throw new Error(`Invalid configuration of route '${e}': routes must have either a path or a matcher specified`); if ("string" == typeof t.path && "/" === t.path.charAt(0)) throw new Error(`Invalid configuration of route '${e}': path cannot start with a slash`); if ("" === t.path && void 0 !== t.redirectTo && void 0 === t.pathMatch) throw new Error(`Invalid configuration of route '{path: "${e}", redirectTo: "${t.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`); if (void 0 !== t.pathMatch && "full" !== t.pathMatch && "prefix" !== t.pathMatch) throw new Error(`Invalid configuration of route '${e}': pathMatch can only be set to 'prefix' or 'full'`); t.children && Nd(t.children, e) } function Ud(t, e) { return e ? t || e.path ? t && !e.path ? t + "/" : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Md(t) { const e = t.children && t.children.map(Md), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && n.outlet !== Zc && (n.component = jd), n } const Fd = new Dt("ROUTES"); class Ld { constructor(t, e, n, r) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = r } load(t, e) { return this.onLoadStartListener && this.onLoadStartListener(e), this.loadModuleFactory(e.loadChildren).pipe(T(n => { this.onLoadEndListener && this.onLoadEndListener(e); const r = n.create(t); return new Xh(th(r.injector.get(Fd)).map(Md), r) })) } loadModuleFactory(t) { return "string" == typeof t ? D(this.loader.load(t)) : rh(t()).pipe(L(t => t instanceof Yt ? Uu(t) : D(this.compiler.compileModuleAsync(t)))) } } class Hd { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new $d, this.attachRef = null } } class $d { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new Hd, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class zd { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function Bd(t) { throw t } function qd(t, e, n) { return e.parse("/") } function Wd(t, e) { return Uu(null) } let Zd = (() => { class t { constructor(t, e, n, r, s, i, o, a) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = r, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.lastLocationChangeInfo = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new S, this.errorHandler = Bd, this.malformedUriErrorHandler = qd, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: Wd, afterPreactivation: Wd }, this.urlHandlingStrategy = new zd, this.routeReuseStrategy = new Vd, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "legacy", this.ngModule = s.get(Jt), this.console = s.get(La); const l = s.get(Xa); this.isNgZoneEnabled = l instanceof Xa, this.resetConfig(a), this.currentUrlTree = new ih(new oh([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new Ld(i, o, t => this.triggerEvent(new Lc(t)), t => this.triggerEvent(new Hc(t))), this.routerState = Ih(this.currentUrlTree, this.rootComponentType), this.transitions = new Mu({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(Ku(t => 0 !== t.id), T(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), cc(t => { let n = !1, r = !1; return Uu(t).pipe(Ec(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), cc(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return Uu(t).pipe(cc(t => { const n = this.transitions.getValue(); return e.next(new Ic(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? Wu : [t] }), cc(t => Promise.resolve(t)), (r = this.ngModule.injector, s = this.configLoader, i = this.urlSerializer, o = this.config, function (t) { return t.pipe(cc(t => function (t, e, n, r, s) { return new ud(t, e, n, r, s).apply() }(r, s, i, t.extractedUrl, o).pipe(T(e => Object.assign(Object.assign({}, t), { urlAfterRedirects: e }))))) }), Ec(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, r, s) { return function (i) { return i.pipe(L(i => function (t, e, n, r, s = "emptyOnly", i = "legacy") { return new xd(t, e, n, r, s, i).recognize() }(t, e, i.urlAfterRedirects, n(i.urlAfterRedirects), r, s).pipe(T(t => Object.assign(Object.assign({}, i), { targetSnapshot: t }))))) } }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Ec(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), Ec(t => { const n = new Nc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); var r, s, i, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: r, source: s, restoredState: i, extras: o } = t, a = new Ic(n, this.serializeUrl(r), s, i); e.next(a); const l = Ih(r, this.rootComponentType).snapshot; return Uu(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: r, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), Wu }), Pd(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), Ec(t => { const e = new Dc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), T(t => Object.assign(Object.assign({}, t), { guards: md(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return function (n) { return n.pipe(L(n => { const { targetSnapshot: r, currentSnapshot: s, guards: { canActivateChecks: i, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === i.length ? Uu(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (t, e, n, r) { return D(t).pipe(L(t => function (t, e, n, r, s) { const i = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return i && 0 !== i.length ? Uu(i.map(i => { const o = yd(i, e, s); let a; if (function (t) { return t && td(t.canDeactivate) }(o)) a = rh(o.canDeactivate(t, e, n, r)); else { if (!td(o)) throw new Error("Invalid CanDeactivate guard"); a = rh(o(t, e, n, r)) } return a.pipe(Sc()) })).pipe(rd()) : Uu(!0) }(t.component, t.route, n, e, r)), Sc(t => !0 !== t, !0)) }(o, r, s, t).pipe(L(n => n && "boolean" == typeof n ? function (t, e, n, r) { return D(e).pipe(Cc(e => D([wd(e.route.parent, r), vd(e.route, r), Cd(t, e.path, n), bd(t, e.route, n)]).pipe(Qu(), Sc(t => !0 !== t, !0))), Sc(t => !0 !== t, !0)) }(r, i, t, e) : Uu(n)), T(t => Object.assign(Object.assign({}, n), { guardsResult: t }))) })) } }(this.ngModule.injector, t => this.triggerEvent(t)), Ec(t => { if (ed(t.guardsResult)) { const e = Kc(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } }), Ec(t => { const e = new Uc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), Ku(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new Vc(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(n), t.resolve(!1), !1 } return !0 }), Pd(t => { if (t.guards.canActivateChecks.length) return Uu(t).pipe(Ec(t => { const e = new Mc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), cc(t => { let n = !1; return Uu(t).pipe((r = this.paramsInheritanceStrategy, s = this.ngModule.injector, function (t) { return t.pipe(L(t => { const { targetSnapshot: e, guards: { canActivateChecks: n } } = t; if (!n.length) return Uu(t); let i = 0; return D(n).pipe(Cc(t => function (t, e, n, r) { return function (t, e, n, r) { const s = Object.keys(t); if (0 === s.length) return Uu({}); const i = {}; return D(s).pipe(L(s => function (t, e, n, r) { const s = yd(t, e, r); return rh(s.resolve ? s.resolve(e, n) : s(e, n)) }(t[s], e, n, r).pipe(Ec(t => { i[s] = t }))), tc(1), L(() => Object.keys(i).length === s.length ? Uu(i) : Wu)) }(t._resolve, t, e, r).pipe(T(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), Vh(t, n).resolve), null))) }(t.route, e, r, s)), Ec(() => i++), tc(1), L(e => i === n.length ? Uu(t) : Wu)) })) }), Ec({ next: () => n = !0, complete: () => { if (!n) { const n = new Vc(t.id, this.serializeUrl(t.extractedUrl), "At least one route resolver didn't emit any value."); e.next(n), t.resolve(!1) } } })); var r, s }), Ec(t => { const e = new Fc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })) }), Pd(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), T(t => { const e = function (t, e, n) { const r = function t(e, n, r) { if (r && e.shouldReuseRoute(n.value, r.value.snapshot)) { const s = r.value; s._futureSnapshot = n.value; const i = function (e, n, r) { return n.children.map(n => { for (const s of r.children) if (e.shouldReuseRoute(s.value.snapshot, n.value)) return t(e, n, s); return t(e, n) }) }(e, n, r); return new kh(s, i) } { const r = e.retrieve(n.value); if (r) { const t = r.route; return function t(e, n) { if (e.value.routeConfig !== n.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (e.children.length !== n.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); n.value._futureSnapshot = e.value; for (let r = 0; r < e.children.length; ++r)t(e.children[r], n.children[r]) }(n, t), t } { const r = new Ph(new Mu((s = n.value).url), new Mu(s.params), new Mu(s.queryParams), new Mu(s.fragment), new Mu(s.data), s.outlet, s.component, s), i = n.children.map(n => t(e, n)); return new kh(r, i) } } var s }(t, e._root, n ? n._root : void 0); return new Rh(r, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), Ec(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (i = this.rootContexts, o = this.routeReuseStrategy, a = t => this.triggerEvent(t), T(t => (new Jh(o, t.targetRouterState, t.currentRouterState, a).activate(i), t))), Ec({ next() { n = !0 }, complete() { n = !0 } }), (s = () => { if (!n && !r) { this.resetUrlToCurrentUrlTree(); const n = new Vc(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`); e.next(n), t.resolve(!1) } this.currentNavigation = null }, t => t.lift(new kc(s))), vc(n => { if (r = !0, (s = n) && s.ngNavigationCancelingError) { const r = ed(n.url); r || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const s = new Vc(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(s), r ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); return this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const r = new jc(t.id, this.serializeUrl(t.extractedUrl), n); e.next(r); try { t.resolve(this.errorHandler(n)) } catch (i) { t.reject(i) } } var s; return Wu })); var s, i, o, a })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const e = this.extractLocationChangeInfoFromEvent(t); this.shouldScheduleNavigation(this.lastLocationChangeInfo, e) && setTimeout(() => { const { source: t, state: n, urlTree: r } = e, s = { replaceUrl: !0 }; if (n) { const t = Object.assign({}, n); delete t.navigationId, 0 !== Object.keys(t).length && (s.state = t) } this.scheduleNavigation(r, t, n, s) }, 0), this.lastLocationChangeInfo = e })) } extractLocationChangeInfoFromEvent(t) { var e; return { source: "popstate" === t.type ? "popstate" : "hashchange", urlTree: this.parseUrl(t.url), state: (null === (e = t.state) || void 0 === e ? void 0 : e.navigationId) ? t.state : null, transitionId: this.getTransition().id } } shouldScheduleNavigation(t, e) { if (!t) return !0; const n = e.urlTree.toString() === t.urlTree.toString(); return !(e.transitionId === t.transitionId && n && ("hashchange" === e.source && "popstate" === t.source || "popstate" === e.source && "hashchange" === t.source)) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { Nd(t), this.config = t.map(Md), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0) } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: r, fragment: s, preserveQueryParams: i, queryParamsHandling: o, preserveFragment: a } = e; mr() && i && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."); const l = n || this.routerState.root, u = a ? this.currentUrlTree.fragment : s; let c = null; if (o) switch (o) { case "merge": c = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), r); break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = r || null } else c = i ? this.currentUrlTree.queryParams : r || null; return null !== c && (c = this.removeEmptyProps(c)), function (t, e, n, r, s) { if (0 === n.length) return $h(e.root, e.root, e, r, s); const i = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new zh(!0, 0, t); let e = 0, n = !1; const r = t.reduce((t, r, s) => { if ("object" == typeof r && null != r) { if (r.outlets) { const e = {}; return nh(r.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (r.segmentPath) return [...t, r.segmentPath] } return "string" != typeof r ? [...t, r] : 0 === s ? (r.split("/").forEach((r, s) => { 0 == s && "." === r || (0 == s && "" === r ? n = !0 : ".." === r ? e++ : "" != r && t.push(r)) }), t) : [...t, r] }, []); return new zh(n, e, r) }(n); if (i.toRoot()) return $h(e.root, new oh([], {}), e, r, s); const o = function (t, e, n) { if (t.isAbsolute) return new Bh(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const t = n.snapshot._urlSegment; return new Bh(t, t === e.root, 0) } const r = Lh(t.commands[0]) ? 0 : 1; return function (t, e, n) { let r = t, s = e, i = n; for (; i > s;) { if (i -= s, r = r.parent, !r) throw new Error("Invalid number of '../'"); s = r.segments.length } return new Bh(r, !1, s - i) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, t.numberOfDoubleDots) }(i, e, t), a = o.processChildren ? Wh(o.segmentGroup, o.index, i.commands) : qh(o.segmentGroup, o.index, i.commands); return $h(o.segmentGroup, a, e, r, s) }(l, this.currentUrlTree, t, c, u) } navigateByUrl(t, e = { skipLocationChange: !1 }) { mr() && this.isNgZoneEnabled && !Xa.isInAngularZone() && this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"); const n = ed(t) ? t : this.parseUrl(t), r = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(r, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { if (ed(t)) return sh(this.currentUrlTree, t, e); const n = this.parseUrl(t); return sh(this.currentUrlTree, n, e) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const r = t[n]; return null != r && (e[n] = r), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new Pc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.currentNavigation = null, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, r, s) { const i = this.getTransition(), o = "imperative" !== e && "imperative" === (null == i ? void 0 : i.source), a = (this.lastSuccessfulId === i.id || this.currentNavigation ? i.rawUrl : i.urlAfterRedirects).toString() === t.toString(); if (o && a) return Promise.resolve(!0); let l, u, c; s ? (l = s.resolve, u = s.reject, c = s.promise) : c = new Promise((t, e) => { l = t, u = e }); const h = ++this.navigationId; return this.setTransition({ id: h, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: r, resolve: l, reject: u, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, n, r) { const s = this.urlSerializer.serialize(t); r = r || {}, this.location.isCurrentPathEqualTo(s) || e ? this.location.replaceState(s, "", Object.assign(Object.assign({}, r), { navigationId: n })) : this.location.go(s, "", Object.assign(Object.assign({}, r), { navigationId: n })) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(ii), Zt(ch), Zt($d), Zt(Wl), Zt(wi), Zt(wl), Zt(Ka), Zt(void 0)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), Gd = (() => { class t { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.onChanges = new S, this.subscription = t.events.subscribe(t => { t instanceof Pc && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } set preserveQueryParams(t) { mr() && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."), this.preserve = t } ngOnChanges(t) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, r, s) { if (0 !== t || e || n || r || s) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const i = { skipLocationChange: Qd(this.skipLocationChange), replaceUrl: Qd(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, i), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Qd(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Qd(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Zd), Di(Ph), Di(Hl)) }, t.\u0275dir = ye({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && Bi("click", (function (t) { return e.onClick(t.button, t.ctrlKey, t.shiftKey, t.altKey, t.metaKey) })), 2 & t && (yo("href", e.href, wr), ji("target", e.target)) }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" }, features: [De] }), t })(); function Qd(t) { return "" === t || !!t } let Kd = (() => { class t { constructor(t, e, n, r, s) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new wa, this.deactivateEvents = new wa, this.name = r || Zc, t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), r = this.parentContexts.getOrCreateContext(this.name).children, s = new Jd(t, r, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(Di($d), Di(ua), Di(Do), ("name", function (t, e) { const n = t.attrs; if (n) { const t = n.length; let r = 0; for (; r < t;) { const s = n[r]; if (Un(s)) break; if (0 === s) r += 2; else if ("number" == typeof s) for (r++; r < t && "string" == typeof n[r];)r++; else { if (s === e) return n[r + 1]; r += 2 } } } return null }(on(), "name")), Di(ri)) }, t.\u0275dir = ye({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class Jd { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === Ph ? this.route : t === $d ? this.childContexts : this.parent.get(t, e) } } class Yd { } class Xd { preload(t, e) { return Uu(null) } } let tp = (() => { class t { constructor(t, e, n, r, s) { this.router = t, this.injector = r, this.preloadingStrategy = s, this.loader = new Ld(e, n, e => t.triggerEvent(new Lc(e)), e => t.triggerEvent(new Hc(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(Ku(t => t instanceof Pc), Cc(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(Jt); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const r of e) if (r.loadChildren && !r.canLoad && r._loadedConfig) { const t = r._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else r.loadChildren && !r.canLoad ? n.push(this.preloadConfig(t, r)) : r.children && n.push(this.processRoutes(t, r.children)); return D(n).pipe(z(), T(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => this.loader.load(t.injector, e).pipe(L(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Zd), Zt(wl), Zt(Ka), Zt(wi), Zt(Yd)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), ep = (() => { class t { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof Ic ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof Pc && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof Wc && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new Wc(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Zd), Zt(ou), Zt(void 0)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const np = new Dt("ROUTER_CONFIGURATION"), rp = new Dt("ROUTER_FORROOT_GUARD"), sp = [Wl, { provide: ch, useClass: hh }, { provide: Zd, useFactory: function (t, e, n, r, s, i, o, a = {}, l, u) { const c = new Zd(null, t, e, n, r, s, i, th(o)); if (l && (c.urlHandlingStrategy = l), u && (c.routeReuseStrategy = u), a.errorHandler && (c.errorHandler = a.errorHandler), a.malformedUriErrorHandler && (c.malformedUriErrorHandler = a.malformedUriErrorHandler), a.enableTracing) { const t = Rl(); c.events.subscribe(e => { t.logGroup("Router Event: " + e.constructor.name), t.log(e.toString()), t.log(e), t.logGroupEnd() }) } return a.onSameUrlNavigation && (c.onSameUrlNavigation = a.onSameUrlNavigation), a.paramsInheritanceStrategy && (c.paramsInheritanceStrategy = a.paramsInheritanceStrategy), a.urlUpdateStrategy && (c.urlUpdateStrategy = a.urlUpdateStrategy), a.relativeLinkResolution && (c.relativeLinkResolution = a.relativeLinkResolution), c }, deps: [ch, $d, Wl, wi, wl, Ka, Fd, np, [class { }, new nt], [class { }, new nt]] }, $d, { provide: Ph, useFactory: function (t) { return t.routerState.root }, deps: [Zd] }, { provide: wl, useClass: Sl }, tp, Xd, class { preload(t, e) { return e().pipe(vc(() => Uu(null))) } }, { provide: np, useValue: { enableTracing: !1 } }]; function ip() { return new pl("Router", Zd) } let op = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [sp, cp(e), { provide: rp, useFactory: up, deps: [[Zd, new nt, new st]] }, { provide: np, useValue: n || {} }, { provide: Hl, useFactory: lp, deps: [Pl, [new et(zl), new nt], np] }, { provide: ep, useFactory: ap, deps: [Zd, ou, np] }, { provide: Yd, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : Xd }, { provide: pl, multi: !0, useFactory: ip }, [hp, { provide: Pa, multi: !0, useFactory: dp, deps: [hp] }, { provide: fp, useFactory: pp, deps: [hp] }, { provide: Fa, multi: !0, useExisting: fp }]] } } static forChild(e) { return { ngModule: t, providers: [cp(e)] } } } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t)(Zt(rp, 8), Zt(Zd, 8)) } }), t })(); function ap(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new ep(t, e, n) } function lp(t, e, n = {}) { return n.useHash ? new ql(t, e) : new Bl(t, e) } function up(t) { if (t) throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function cp(t) { return [{ provide: bi, multi: !0, useValue: t }, { provide: Fd, multi: !0, useValue: t }] } let hp = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new S } appInitializer() { return this.injector.get(jl, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(Zd), r = this.injector.get(np); if (this.isLegacyDisabled(r) || this.isLegacyEnabled(r)) t(!0); else if ("disabled" === r.initialNavigation) n.setUpLocationChangeListener(), t(!0); else { if ("enabled" !== r.initialNavigation) throw new Error(`Invalid initialNavigation options: '${r.initialNavigation}'`); n.hooks.afterPreactivation = () => this.initNavigation ? Uu(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation() } return e }) } bootstrapListener(t) { const e = this.injector.get(np), n = this.injector.get(tp), r = this.injector.get(ep), s = this.injector.get(Zd), i = this.injector.get(_l); t === i.components[0] && (this.isLegacyEnabled(e) ? s.initialNavigation() : this.isLegacyDisabled(e) && s.setUpLocationChangeListener(), n.setUpPreloading(), r.init(), s.resetRootComponentType(i.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } isLegacyEnabled(t) { return "legacy_enabled" === t.initialNavigation || !0 === t.initialNavigation || void 0 === t.initialNavigation } isLegacyDisabled(t) { return "legacy_disabled" === t.initialNavigation || !1 === t.initialNavigation } } return t.\u0275fac = function (e) { return new (e || t)(Zt(wi)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); function dp(t) { return t.appInitializer.bind(t) } function pp(t) { return t.bootstrapListener.bind(t) } const fp = new Dt("Router Initializer"); class gp { } class mp { } class yp { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), r = n.toLowerCase(), s = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, r), this.headers.has(r) ? this.headers.get(r).push(s) : this.headers.set(r, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const r = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(r, n), this.maybeSetNormalizedName(e, r)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof yp ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new yp; return e.lazyInit = this.lazyInit && this.lazyInit instanceof yp ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const r = ("a" === t.op ? this.headers.get(e) : void 0) || []; r.push(...n), this.headers.set(e, r); break; case "d": const s = t.value; if (s) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === s.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class _p { encodeKey(t) { return vp(t) } encodeValue(t) { return vp(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function vp(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } class wp { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new _p, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.split("&").forEach(t => { const r = t.indexOf("="), [s, i] = -1 == r ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, r)), e.decodeValue(t.slice(r + 1))], o = n.get(s) || []; o.push(i), n.set(s, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new wp({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat([t]), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(t.value), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(t.value); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } function bp(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function Cp(t) { return "undefined" != typeof Blob && t instanceof Blob } function Sp(t) { return "undefined" != typeof FormData && t instanceof FormData } class xp { constructor(t, e, n, r) { let s; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== n ? n : null, s = r) : s = n, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.params && (this.params = s.params)), this.headers || (this.headers = new yp), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new wp, this.urlWithParams = e } serializeBody() { return null === this.body ? null : bp(this.body) || Cp(this.body) || Sp(this.body) || "string" == typeof this.body ? this.body : this.body instanceof wp ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || Sp(this.body) ? null : Cp(this.body) ? this.body.type || null : bp(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof wp ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null } clone(t = {}) { const e = t.method || this.method, n = t.url || this.url, r = t.responseType || this.responseType, s = void 0 !== t.body ? t.body : this.body, i = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, o = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let a = t.headers || this.headers, l = t.params || this.params; return void 0 !== t.setHeaders && (a = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), a)), t.setParams && (l = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), l)), new xp(e, n, s, { params: l, headers: a, reportProgress: o, responseType: r, withCredentials: i }) } } var Ep = function (t) { return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t }({}); class Tp { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new yp, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Ap extends Tp { constructor(t = {}) { super(t), this.type = Ep.ResponseHeader } clone(t = {}) { return new Ap({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class kp extends Tp { constructor(t = {}) { super(t), this.type = Ep.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new kp({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Op extends Tp { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? "Http failure during parsing for " + (t.url || "(unknown url)") : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function Rp(t, e) { return { body: e, headers: t.headers, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let Ip = (() => { class t { constructor(t) { this.handler = t } request(t, e, n = {}) { let r; if (t instanceof xp) r = t; else { let s = void 0; s = n.headers instanceof yp ? n.headers : new yp(n.headers); let i = void 0; n.params && (i = n.params instanceof wp ? n.params : new wp({ fromObject: n.params })), r = new xp(t, e, void 0 !== n.body ? n.body : null, { headers: s, params: i, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const s = Uu(r).pipe(Cc(t => this.handler.handle(t))); if (t instanceof xp || "events" === n.observe) return s; const i = s.pipe(Ku(t => t instanceof kp)); switch (n.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return i.pipe(T(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return i.pipe(T(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return i.pipe(T(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return i.pipe(T(t => t.body)) }case "response": return i; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new wp).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, Rp(n, e)) } post(t, e, n = {}) { return this.request("POST", t, Rp(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, Rp(n, e)) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(gp)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); class Pp { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const Vp = new Dt("HTTP_INTERCEPTORS"); let jp = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const Np = /^\)\]\}',?\n/; class Dp { } let Up = (() => { class t { constructor() { } build() { return new XMLHttpRequest } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), Mp = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new _(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const r = t.serializeBody(); let s = null; const i = () => { if (null !== s) return s; const e = 1223 === n.status ? 204 : n.status, r = n.statusText || "OK", i = new yp(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return s = new Ap({ headers: i, status: e, statusText: r, url: o }), s }, o = () => { let { headers: r, status: s, statusText: o, url: a } = i(), l = null; 204 !== s && (l = void 0 === n.response ? n.responseText : n.response), 0 === s && (s = l ? 200 : 0); let u = s >= 200 && s < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l; l = l.replace(Np, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (c) { l = t, u && (u = !1, l = { error: c, text: l }) } } u ? (e.next(new kp({ body: l, headers: r, status: s, statusText: o, url: a || void 0 })), e.complete()) : e.error(new Op({ error: l, headers: r, status: s, statusText: o, url: a || void 0 })) }, a = t => { const { url: r } = i(), s = new Op({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: r || void 0 }); e.error(s) }; let l = !1; const u = r => { l || (e.next(i()), l = !0); let s = { type: Ep.DownloadProgress, loaded: r.loaded }; r.lengthComputable && (s.total = r.total), "text" === t.responseType && n.responseText && (s.partialText = n.responseText), e.next(s) }, c = t => { let n = { type: Ep.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), t.reportProgress && (n.addEventListener("progress", u), null !== r && n.upload && n.upload.addEventListener("progress", c)), n.send(r), e.next({ type: Ep.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("load", o), t.reportProgress && (n.removeEventListener("progress", u), null !== r && n.upload && n.upload.removeEventListener("progress", c)), n.readyState !== n.DONE && n.abort() } }) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Dp)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(); const Fp = new Dt("XSRF_COOKIE_NAME"), Lp = new Dt("XSRF_HEADER_NAME"); class Hp { } let $p = (() => { class t { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++ , this.lastToken = Yl(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Il), Zt(Ma), Zt(Fp)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), zp = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const r = this.tokenService.getToken(); return null === r || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, r) })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Hp), Zt(Lp)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), Bp = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(Vp, []); this.chain = t.reduceRight((t, e) => new Pp(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(mp), Zt(wi)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), qp = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: zp, useClass: jp }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: Fp, useValue: e.cookieName } : [], e.headerName ? { provide: Lp, useValue: e.headerName } : []] } } } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [zp, { provide: Vp, useExisting: zp, multi: !0 }, { provide: Hp, useClass: $p }, { provide: Fp, useValue: "XSRF-TOKEN" }, { provide: Lp, useValue: "X-XSRF-TOKEN" }] }), t })(), Wp = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [Ip, { provide: gp, useClass: Bp }, Mp, { provide: mp, useExisting: Mp }, Up, { provide: Dp, useExisting: Up }], imports: [[qp.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })(), Zp = (() => { class t { constructor(t) { this.http = t } getAll() { return this.http.get(kl + "/api/default") } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Ip)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function Gp(t, e) { if (1 & t && (Fi(0, "li"), po(1), Li()), 2 & t) { const t = e.$implicit; Mr(1), mo(" ", t.nombre, " ", t.apellido, " ") } } let Qp = (() => { class t { constructor(t) { this.valuesService = t } ngOnInit() { this.valuesService.getAll().subscribe(t => { this.values = t }) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Zp)) }, t.\u0275cmp = he({ type: t, selectors: [["app-home"]], decls: 5, vars: 1, consts: [[4, "ngFor", "ngForOf"]], template: function (t, e) { 1 & t && (Fi(0, "div"), Fi(1, "h1"), po(2, "Datos desde la api de MVC"), Li(), Fi(3, "ul"), Ni(4, Gp, 2, 2, "li", 0), Li(), Li()), 2 & t && (Mr(4), Ui("ngForOf", e.values)) }, directives: [tu], styles: [""] }), t })(); function Kp(t, e) { return new _(n => { const r = t.length; if (0 === r) return void n.complete(); const s = new Array(r); let i = 0, o = 0; for (let a = 0; a < r; a++) { const l = D(t[a]); let u = !1; n.add(l.subscribe({ next: t => { u || (u = !0, o++), s[a] = t }, error: t => n.error(t), complete: () => { i++ , i !== r && u || (o === r && n.next(e ? e.reduce((t, e, n) => (t[e] = s[n], t), {}) : s), n.complete()) } })) } }) } const Jp = new Dt("NgValueAccessor"), Yp = { provide: Jp, useExisting: bt(() => Xp), multi: !0 }; let Xp = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "checked", t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ho), Di(Uo)) }, t.\u0275dir = ye({ type: t, selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Bi("change", (function (t) { return e.onChange(t.target.checked) }))("blur", (function () { return e.onTouched() })) }, features: [Vo([Yp])] }), t })(); const tf = { provide: Jp, useExisting: bt(() => nf), multi: !0 }, ef = new Dt("CompositionEventMode"); let nf = (() => { class t { constructor(t, e, n) { this._renderer = t, this._elementRef = e, this._compositionMode = n, this.onChange = t => { }, this.onTouched = () => { }, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = Rl() ? Rl().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ho), Di(Uo), Di(ef, 8)) }, t.\u0275dir = ye({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, e) { 1 & t && Bi("input", (function (t) { return e._handleInput(t.target.value) }))("blur", (function () { return e.onTouched() }))("compositionstart", (function () { return e._compositionStart() }))("compositionend", (function (t) { return e._compositionEnd(t.target.value) })) }, features: [Vo([tf])] }), t })(), rf = (() => { class t { get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = ye({ type: t }), t })(), sf = (() => { class t extends rf { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function (e) { return of(e || t) }, t.\u0275dir = ye({ type: t, features: [xi] }), t })(); const of = ar(sf); class af extends rf { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null, this._rawValidators = [], this._rawAsyncValidators = [] } get validator() { } get asyncValidator() { } } class lf { constructor(t) { this._cd = t } get ngClassUntouched() { return !!this._cd.control && this._cd.control.untouched } get ngClassTouched() { return !!this._cd.control && this._cd.control.touched } get ngClassPristine() { return !!this._cd.control && this._cd.control.pristine } get ngClassDirty() { return !!this._cd.control && this._cd.control.dirty } get ngClassValid() { return !!this._cd.control && this._cd.control.valid } get ngClassInvalid() { return !!this._cd.control && this._cd.control.invalid } get ngClassPending() { return !!this._cd.control && this._cd.control.pending } } let uf = (() => { class t extends lf { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Di(af, 2)) }, t.\u0275dir = ye({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && eo("ng-untouched", e.ngClassUntouched)("ng-touched", e.ngClassTouched)("ng-pristine", e.ngClassPristine)("ng-dirty", e.ngClassDirty)("ng-valid", e.ngClassValid)("ng-invalid", e.ngClassInvalid)("ng-pending", e.ngClassPending) }, features: [xi] }), t })(), cf = (() => { class t extends lf { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Di(sf, 2)) }, t.\u0275dir = ye({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && eo("ng-untouched", e.ngClassUntouched)("ng-touched", e.ngClassTouched)("ng-pristine", e.ngClassPristine)("ng-dirty", e.ngClassDirty)("ng-valid", e.ngClassValid)("ng-invalid", e.ngClassInvalid)("ng-pending", e.ngClassPending) }, features: [xi] }), t })(); function hf(t) { return null == t || 0 === t.length } function df(t) { return null != t && "number" == typeof t.length } const pf = new Dt("NgValidators"), ff = new Dt("NgAsyncValidators"), gf = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class mf { static min(t) { return e => { if (hf(e.value) || hf(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n < t ? { min: { min: t, actual: e.value } } : null } } static max(t) { return e => { if (hf(e.value) || hf(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n > t ? { max: { max: t, actual: e.value } } : null } } static required(t) { return hf(t.value) ? { required: !0 } : null } static requiredTrue(t) { return !0 === t.value ? null : { required: !0 } } static email(t) { return hf(t.value) || gf.test(t.value) ? null : { email: !0 } } static minLength(t) { return e => hf(e.value) || !df(e.value) ? null : e.value.length < t ? { minlength: { requiredLength: t, actualLength: e.value.length } } : null } static maxLength(t) { return e => df(e.value) && e.value.length > t ? { maxlength: { requiredLength: t, actualLength: e.value.length } } : null } static pattern(t) { if (!t) return mf.nullValidator; let e, n; return "string" == typeof t ? (n = "", "^" !== t.charAt(0) && (n += "^"), n += t, "$" !== t.charAt(t.length - 1) && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), t => { if (hf(t.value)) return null; const r = t.value; return e.test(r) ? null : { pattern: { requiredPattern: n, actualValue: r } } } } static nullValidator(t) { return null } static compose(t) { if (!t) return null; const e = t.filter(yf); return 0 == e.length ? null : function (t) { return vf(wf(t, e)) } } static composeAsync(t) { if (!t) return null; const e = t.filter(yf); return 0 == e.length ? null : function (t) { return function (...t) { if (1 === t.length) { const e = t[0]; if (l(e)) return Kp(e, null); if (u(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return Kp(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return Kp(t = 1 === t.length && l(t[0]) ? t[0] : t, null).pipe(T(t => e(...t))) } return Kp(t, null) }(wf(t, e).map(_f)).pipe(T(vf)) } } } function yf(t) { return null != t } function _f(t) { const e = $i(t) ? D(t) : t; return zi(e), e } function vf(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e } function wf(t, e) { return e.map(e => e(t)) } function bf(t) { return t.map(t => function (t) { return !t.validate }(t) ? t : e => t.validate(e)) } const Cf = { provide: Jp, useExisting: bt(() => Sf), multi: !0 }; let Sf = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ho), Di(Uo)) }, t.\u0275dir = ye({ type: t, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Bi("input", (function (t) { return e.onChange(t.target.value) }))("blur", (function () { return e.onTouched() })) }, features: [Vo([Cf])] }), t })(); const xf = { provide: Jp, useExisting: bt(() => Tf), multi: !0 }; let Ef = (() => { class t { constructor() { this._accessors = [] } add(t, e) { this._accessors.push([t, e]) } remove(t) { for (let e = this._accessors.length - 1; e >= 0; --e)if (this._accessors[e][1] === t) return void this._accessors.splice(e, 1) } select(t) { this._accessors.forEach(e => { this._isSameGroup(e, t) && e[1] !== t && e[1].fireUncheck(t.value) }) } _isSameGroup(t, e) { return !!t[0].control && t[0]._parent === e._control._parent && t[1].name === e.name } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), Tf = (() => { class t { constructor(t, e, n, r) { this._renderer = t, this._elementRef = e, this._registry = n, this._injector = r, this.onChange = () => { }, this.onTouched = () => { } } ngOnInit() { this._control = this._injector.get(af), this._checkName(), this._registry.add(this._control, this) } ngOnDestroy() { this._registry.remove(this) } writeValue(t) { this._state = t === this.value, this._renderer.setProperty(this._elementRef.nativeElement, "checked", this._state) } registerOnChange(t) { this._fn = t, this.onChange = () => { t(this.value), this._registry.select(this) } } fireUncheck(t) { this.writeValue(t) } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _checkName() { !this.name && this.formControlName && (this.name = this.formControlName) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ho), Di(Uo), Di(Ef), Di(wi)) }, t.\u0275dir = ye({ type: t, selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Bi("change", (function () { return e.onChange() }))("blur", (function () { return e.onTouched() })) }, inputs: { name: "name", formControlName: "formControlName", value: "value" }, features: [Vo([xf])] }), t })(); const Af = { provide: Jp, useExisting: bt(() => kf), multi: !0 }; let kf = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", parseFloat(t)) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ho), Di(Uo)) }, t.\u0275dir = ye({ type: t, selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Bi("change", (function (t) { return e.onChange(t.target.value) }))("input", (function (t) { return e.onChange(t.target.value) }))("blur", (function () { return e.onTouched() })) }, features: [Vo([Af])] }), t })(); const Of = { provide: Jp, useExisting: bt(() => Rf), multi: !0 }; let Rf = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const e = this._getOptionId(t); null == e && this._renderer.setProperty(this._elementRef.nativeElement, "selectedIndex", -1); const n = function (t, e) { return null == t ? "" + e : (e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) }(e, t); this._renderer.setProperty(this._elementRef.nativeElement, "value", n) } registerOnChange(t) { this.onChange = e => { this.value = this._getOptionValue(e), t(this.value) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e), t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e) : t } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ho), Di(Uo)) }, t.\u0275dir = ye({ type: t, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (t, e) { 1 & t && Bi("change", (function (t) { return e.onChange(t.target.value) }))("blur", (function () { return e.onTouched() })) }, inputs: { compareWith: "compareWith" }, features: [Vo([Of])] }), t })(); const If = { provide: Jp, useExisting: bt(() => Pf), multi: !0 }; let Pf = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let e; if (this.value = t, Array.isArray(t)) { const n = t.map(t => this._getOptionId(t)); e = (t, e) => { t._setSelected(n.indexOf(e.toString()) > -1) } } else e = (t, e) => { t._setSelected(!1) }; this._optionMap.forEach(e) } registerOnChange(t) { this.onChange = e => { const n = []; if (void 0 !== e.selectedOptions) { const t = e.selectedOptions; for (let e = 0; e < t.length; e++) { const r = t.item(e), s = this._getOptionValue(r.value); n.push(s) } } else { const t = e.options; for (let e = 0; e < t.length; e++) { const r = t.item(e); if (r.selected) { const t = this._getOptionValue(r.value); n.push(t) } } } this.value = n, t(n) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption(t) { const e = (this._idCounter++).toString(); return this._optionMap.set(e, t), e } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e)._value, t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e)._value : t } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ho), Di(Uo)) }, t.\u0275dir = ye({ type: t, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Bi("change", (function (t) { return e.onChange(t.target) }))("blur", (function () { return e.onTouched() })) }, inputs: { compareWith: "compareWith" }, features: [Vo([If])] }), t })(); function Vf(t, e) { t.validator = mf.compose([t.validator, e.validator]), t.asyncValidator = mf.composeAsync([t.asyncValidator, e.asyncValidator]), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && jf(t, e) }) }(t, e), function (t, e) { t.registerOnChange((t, n) => { e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && jf(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), e.valueAccessor.setDisabledState && t.registerOnDisabledChange(t => { e.valueAccessor.setDisabledState(t) }), e._rawValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }), e._rawAsyncValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }) } function jf(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function Nf(t) { return null != t ? mf.compose(bf(t)) : null } function Df(t) { return null != t ? mf.composeAsync(bf(t)) : null } const Uf = [Xp, kf, Sf, Rf, Pf, Tf], Mf = "VALID", Ff = "INVALID", Lf = "PENDING", Hf = "DISABLED"; function $f(t) { return (Wf(t) ? t.validators : t) || null } function zf(t) { return Array.isArray(t) ? Nf(t) : t || null } function Bf(t, e) { return (Wf(e) ? e.asyncValidators : t) || null } function qf(t) { return Array.isArray(t) ? Df(t) : t || null } function Wf(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class Zf { constructor(t, e) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = zf(this._rawValidators), this._composedAsyncValidatorFn = qf(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === Mf } get invalid() { return this.status === Ff } get pending() { return this.status == Lf } get disabled() { return this.status === Hf } get enabled() { return this.status !== Hf } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = zf(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = qf(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = Lf, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = Hf, this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = Mf, this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), this.status !== Mf && this.status !== Lf || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Hf : Mf } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = Lf, this._hasOwnPendingAsyncValidator = !0; const e = _f(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(e, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, n) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let r = t; return e.forEach(t => { r = r instanceof Qf ? r.controls.hasOwnProperty(t) ? r.controls[t] : null : r instanceof Kf && r.at(t) || null }), r }(this, t) } getError(t, e) { const n = e ? this.get(e) : this; return n && n.errors ? n.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new wa, this.statusChanges = new wa } _calculateStatus() { return this._allControlsDisabled() ? Hf : this.errors ? Ff : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Lf) ? Lf : this._anyControlsHaveStatus(Ff) ? Ff : Mf } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { Wf(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && this._parent && this._parent.dirty && !this._parent._anyControlsDirty() } } class Gf extends Zf { constructor(t = null, e, n) { super($f(e), Bf(n, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }), this._initObservables() } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _clearChangeFns() { this._onChange = [], this._onDisabledChange = [], this._onCollectionChange = () => { } } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class Qf extends Zf { constructor(t, e, n) { super($f(e), Bf(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e) { this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } removeControl(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity(), this._onCollectionChange() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { Object.keys(t).forEach(n => { this.controls[n] && this.controls[n].patchValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = {}, e = {}) { this._forEachChild((n, r) => { n.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, n) => (t[n] = e instanceof Gf ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => t(this.controls[e], e)) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const n = this.controls[e]; if (this.contains(e) && t(n)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)) } _reduceChildren(t, e) { let n = t; return this._forEachChild((t, r) => { n = e(n, t, r) }), n } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class Kf extends Zf { constructor(t, e, n) { super($f(e), Bf(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } at(t) { return this.controls[t] } push(t) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity(), this._onCollectionChange() } insert(t, e) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity() } removeAt(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity(), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, n) => { this._throwIfControlMissing(n), this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { t.forEach((t, n) => { this.at(n) && this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = [], e = {}) { this._forEachChild((n, r) => { n.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof Gf ? t.value : t.getRawValue()) } clear() { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity()) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error("Cannot find form control at index " + t) } _forEachChild(t) { this.controls.forEach((e, n) => { t(e, n) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const Jf = { provide: sf, useExisting: bt(() => Xf) }, Yf = (() => Promise.resolve(null))(); let Xf = (() => { class t extends sf { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new wa, this.form = new Qf({}, Nf(t), Df(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Yf.then(() => { const e = this._findContainer(t.path); t.control = e.registerControl(t.name, t.control), Vf(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Yf.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name), function (t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) }(this._directives, t) }) } addFormGroup(t) { Yf.then(() => { const e = this._findContainer(t.path), n = new Qf({}); (function (t, e) { t.validator = mf.compose([t.validator, e.validator]), t.asyncValidator = mf.composeAsync([t.asyncValidator, e.asyncValidator]) })(n, t), e.registerControl(t.name, n), n.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Yf.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { Yf.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, e = this._directives, this.form._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }), this.ngSubmit.emit(t), !1; var e } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return t.\u0275fac = function (e) { return new (e || t)(Di(pf, 10), Di(ff, 10)) }, t.\u0275dir = ye({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, e) { 1 & t && Bi("submit", (function (t) { return e.onSubmit(t) }))("reset", (function () { return e.onReset() })) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Vo([Jf]), xi] }), t })(), tg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = ye({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(); const eg = new Dt("NgModelWithFormControlWarning"), ng = { provide: af, useExisting: bt(() => rg) }; let rg = (() => { class t extends af { constructor(t, e, n, r) { super(), this._ngModelWarningConfig = r, this.update = new wa, this._ngModelWarningSent = !1, this._rawValidators = t || [], this._rawAsyncValidators = e || [], this.valueAccessor = function (t, e) { if (!e) return null; Array.isArray(e); let n = void 0, r = void 0, s = void 0; return e.forEach(t => { var e; t.constructor === nf ? n = t : (e = t, Uf.some(t => e.constructor === t) ? r = t : s = t) }), s || r || n || null }(0, n) } set isDisabled(t) { } ngOnChanges(e) { var n, r; this._isControlChanged(e) && (Vf(this.form, this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this.form.updateValueAndValidity({ emitEvent: !1 })), function (t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Object.is(e, n.currentValue) }(e, this.viewModel) && (n = t, this, r = this._ngModelWarningConfig, mr() && "never" !== r && ((null !== r && "once" !== r || n._ngModelWarningSentOnce) && ("always" !== r || this._ngModelWarningSent) || (n._ngModelWarningSentOnce = !0, this._ngModelWarningSent = !0)), this.form.setValue(this.model), this.viewModel = this.model) } get path() { return [] } get validator() { return Nf(this._rawValidators) } get asyncValidator() { return Df(this._rawAsyncValidators) } get control() { return this.form } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _isControlChanged(t) { return t.hasOwnProperty("form") } } return t.\u0275fac = function (e) { return new (e || t)(Di(pf, 10), Di(ff, 10), Di(Jp, 10), Di(eg, 8)) }, t.\u0275dir = ye({ type: t, selectors: [["", "formControl", ""]], inputs: { isDisabled: ["disabled", "isDisabled"], form: ["formControl", "form"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngForm"], features: [Vo([ng]), xi, De] }), t._ngModelWarningSentOnce = !1, t })(), sg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) } }), t })(), ig = (() => { class t { group(t, e = null) { const n = this._reduceControls(t); let r = null, s = null, i = void 0; return null != e && (function (t) { return void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn }(e) ? (r = null != e.validators ? e.validators : null, s = null != e.asyncValidators ? e.asyncValidators : null, i = null != e.updateOn ? e.updateOn : void 0) : (r = null != e.validator ? e.validator : null, s = null != e.asyncValidator ? e.asyncValidator : null)), new Qf(n, { asyncValidators: s, updateOn: i, validators: r }) } control(t, e, n) { return new Gf(t, e, n) } array(t, e, n) { const r = t.map(t => this._createControl(t)); return new Kf(r, e, n) } _reduceControls(t) { const e = {}; return Object.keys(t).forEach(n => { e[n] = this._createControl(t[n]) }), e } _createControl(t) { return t instanceof Gf || t instanceof Qf || t instanceof Kf ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac }), t })(), og = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [Ef], imports: [sg] }), t })(), ag = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: eg, useValue: e.warnOnNgModelWithFormControl }] } } } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [ig, Ef], imports: [sg] }), t })(), lg = (() => { class t { constructor(t) { this.http = t, this.currentUserSubject = new Mu(JSON.parse(localStorage.getItem("currentUser"))), this.currentUser = this.currentUserSubject.asObservable() } get currentUserValue() { return this.currentUserSubject.value } login(t, e) { return this.http.post(kl + "/api/login/authenticate", { username: t, password: e }).pipe(T(t => (localStorage.setItem("currentUser", JSON.stringify(t)), this.currentUserSubject.next(t), t))) } logout() { localStorage.removeItem("currentUser"), this.currentUserSubject.next(null) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Ip)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function ug(t, e) { if (1 & t && (Fi(0, "div", 8), po(1), Li()), 2 & t) { const t = Zi(); Mr(1), fo(t.error) } } let cg = (() => { class t { constructor(t, e, n) { this.route = t, this.router = e, this.authenticationService = n, this.error = "", this.usernameControl = new Gf("", mf.required), this.passwordControl = new Gf("", mf.required) } ngOnInit() { this.returnUrl = this.route.snapshot.queryParams.returnUrl || "/" } onSubmit() { this.authenticationService.login(this.usernameControl.value, this.passwordControl.value).subscribe(t => { this.router.navigate([this.returnUrl]) }, t => { this.error = t }) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Ph), Di(Zd), Di(lg)) }, t.\u0275cmp = he({ type: t, selectors: [["app-login"]], decls: 12, vars: 3, consts: [[3, "ngSubmit"], [1, "form-group"], ["for", "username"], ["type", "text", "id", "username", "placeholder", "Ingres\xe1 tu nombre de usuario", 1, "form-control", 3, "formControl"], ["for", "password"], ["type", "password", "id", "password", "placeholder", "Contrase\xf1a", 1, "form-control", 3, "formControl"], ["class", "alert alert-danger mt-3 mb-0", 4, "ngIf"], ["type", "submit", 1, "btn", "btn-primary"], [1, "alert", "alert-danger", "mt-3", "mb-0"]], template: function (t, e) { 1 & t && (Fi(0, "form", 0), Bi("ngSubmit", (function () { return e.onSubmit() })), Fi(1, "div", 1), Fi(2, "label", 2), po(3, "Nombre de usuario"), Li(), Hi(4, "input", 3), Li(), Fi(5, "div", 1), Fi(6, "label", 4), po(7, "Contrase\xf1a"), Li(), Hi(8, "input", 5), Li(), Ni(9, ug, 2, 1, "div", 6), Fi(10, "button", 7), po(11, "Enviar"), Li(), Li()), 2 & t && (Mr(4), Ui("formControl", e.usernameControl), Mr(4), Ui("formControl", e.passwordControl), Mr(1), Ui("ngIf", e.error)) }, directives: [tg, cf, Xf, nf, uf, rg, nu], styles: [""] }), t })(); const hg = [{ path: "", component: Qp, canActivate: [(() => { class t { constructor(t, e) { this.router = t, this.authenticationService = e } canActivate(t, e) { return !!this.authenticationService.currentUserValue || (this.router.navigate(["/login"], { queryParams: { returnUrl: e.url } }), !1) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Zd), Zt(lg)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })()] }, { path: "login", component: cg }, { path: "**", redirectTo: "" }]; let dg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[op.forRoot(hg)], op] }), t })(); function pg(t, e, n, s) { return r(n) && (s = n, n = void 0), s ? pg(t, e, n).pipe(T(t => l(t) ? s(...t) : s(t))) : new _(r => { !function t(e, n, r, s, i) { let o; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(e)) { const t = e; e.addEventListener(n, r, i), o = () => t.removeEventListener(n, r, i) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(e)) { const t = e; e.on(n, r), o = () => t.off(n, r) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(e)) { const t = e; e.addListener(n, r), o = () => t.removeListener(n, r) } else { if (!e || !e.length) throw new TypeError("Invalid event target"); for (let o = 0, a = e.length; o < a; o++)t(e[o], n, r, s, i) } s.add(o) }(t, e, (function (t) { r.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }), r, n) }) } class fg extends h { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class gg extends fg { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, r = this.scheduler; return null != n && (this.id = this.recycleAsyncId(r, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n = !1, r = void 0; try { this.work(t) } catch (s) { n = !0, r = !!s && s || new Error(s) } if (n) return this.unsubscribe(), r } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, r = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && n.splice(r, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } let mg = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class yg extends mg { constructor(t, e = mg.now) { super(t, () => yg.delegate && yg.delegate !== this ? yg.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return yg.delegate && yg.delegate !== this ? yg.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } const _g = new yg(gg); function vg(t) { return !l(t) && t - parseFloat(t) + 1 >= 0 } function wg(t) { const { index: e, period: n, subscriber: r } = t; if (r.next(e), !r.closed) { if (-1 === n) return r.complete(); t.index = e + 1, this.schedule(t, n) } } class bg { call(t, e) { return e.subscribe(new Cg(t)) } } class Cg extends Fu { constructor(t) { super(t), this.hasFirst = !1, this.observables = [], this.subscriptions = [] } _next(t) { this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { for (let n = 0; n < e && !this.hasFirst; n++) { const e = Hu(this, t[n], void 0, n); this.subscriptions && this.subscriptions.push(e), this.add(e) } this.observables = null } } notifyNext(t, e, n) { if (!this.hasFirst) { this.hasFirst = !0; for (let t = 0; t < this.subscriptions.length; t++)if (t !== n) { let e = this.subscriptions[t]; e.unsubscribe(), this.remove(e) } this.subscriptions = null } this.destination.next(e) } } function Sg(...t) { const e = t[t.length - 1]; return "function" == typeof e && t.pop(), B(t, void 0).lift(new xg(e)) } class xg { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new Eg(t, this.resultSelector)) } } class Eg extends f { constructor(t, e, n = Object.create(null)) { super(t), this.resultSelector = e, this.iterators = [], this.active = 0, this.resultSelector = "function" == typeof e ? e : void 0 } _next(t) { const e = this.iterators; l(t) ? e.push(new Ag(t)) : e.push("function" == typeof t[I] ? new Tg(t[I]()) : new kg(this.destination, this, t)) } _complete() { const t = this.iterators, e = t.length; if (this.unsubscribe(), 0 !== e) { this.active = e; for (let n = 0; n < e; n++) { let e = t[n]; e.stillUnsubscribed ? this.destination.add(e.subscribe()) : this.active-- } } else this.destination.complete() } notifyInactive() { this.active-- , 0 === this.active && this.destination.complete() } checkIterators() { const t = this.iterators, e = t.length, n = this.destination; for (let i = 0; i < e; i++) { let e = t[i]; if ("function" == typeof e.hasValue && !e.hasValue()) return } let r = !1; const s = []; for (let i = 0; i < e; i++) { let e = t[i], o = e.next(); if (e.hasCompleted() && (r = !0), o.done) return void n.complete(); s.push(o.value) } this.resultSelector ? this._tryresultSelector(s) : n.next(s), r && n.complete() } _tryresultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } class Tg { constructor(t) { this.iterator = t, this.nextResult = t.next() } hasValue() { return !0 } next() { const t = this.nextResult; return this.nextResult = this.iterator.next(), t } hasCompleted() { const t = this.nextResult; return Boolean(t && t.done) } } class Ag { constructor(t) { this.array = t, this.index = 0, this.length = 0, this.length = t.length } [I]() { return this } next(t) { const e = this.index++; return e < this.length ? { value: this.array[e], done: !1 } : { value: null, done: !0 } } hasValue() { return this.array.length > this.index } hasCompleted() { return this.array.length === this.index } } class kg extends M { constructor(t, e, n) { super(t), this.parent = e, this.observable = n, this.stillUnsubscribed = !0, this.buffer = [], this.isComplete = !1 } [I]() { return this } next() { const t = this.buffer; return 0 === t.length && this.isComplete ? { value: null, done: !0 } : { value: t.shift(), done: !1 } } hasValue() { return this.buffer.length > 0 } hasCompleted() { return 0 === this.buffer.length && this.isComplete } notifyComplete() { this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete() } notifyNext(t) { this.buffer.push(t), this.parent.checkIterators() } subscribe() { return F(this.observable, new U(this)) } } function Og(t) { return e => e.lift(new Rg(t)) } class Rg { constructor(t) { this.notifier = t } call(t, e) { const n = new Ig(t), r = F(this.notifier, new U(n)); return r && !n.seenValue ? (n.add(r), e.subscribe(n)) : n } } class Ig extends M { constructor(t) { super(t), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } function Pg(...t) { return e => { let n; return "function" == typeof t[t.length - 1] && (n = t.pop()), e.lift(new Vg(t, n)) } } class Vg { constructor(t, e) { this.observables = t, this.project = e } call(t, e) { return e.subscribe(new jg(t, this.observables, this.project)) } } class jg extends Fu { constructor(t, e, n) { super(t), this.observables = e, this.project = n, this.toRespond = []; const r = e.length; this.values = new Array(r); for (let s = 0; s < r; s++)this.toRespond.push(s); for (let s = 0; s < r; s++)this.add(Hu(this, e[s], void 0, s)) } notifyNext(t, e, n) { this.values[n] = e; const r = this.toRespond; if (r.length > 0) { const t = r.indexOf(n); -1 !== t && r.splice(t, 1) } } notifyComplete() { } _next(t) { if (0 === this.toRespond.length) { const e = [t, ...this.values]; this.project ? this._tryProject(e) : this.destination.next(e) } } _tryProject(t) { let e; try { e = this.project.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const Ng = ["*"], Dg = ["dialog"]; function Ug(t) { return null != t } "undefined" == typeof Element || Element.prototype.closest || (Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest = function (t) { let e = this; if (!document.documentElement.contains(e)) return null; do { if (e.matches(t)) return e; e = e.parentElement || e.parentNode } while (null !== e && 1 === e.nodeType); return null }); const Mg = { animation: !0, transitionTimerDelayMs: 5 }; let Fg = (() => { class t { constructor() { this.animation = Mg.animation } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = lt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const Lg = () => { }, { transitionTimerDelayMs: Hg } = Mg, $g = new Map, zg = (t, e, n) => { let r = n.context || {}; const s = $g.get(t); if (s) switch (n.runningTransition) { case "continue": return Wu; case "stop": s.transition$.complete(), r = Object.assign(s.context, r), $g.delete(t) }!function (t) { t || document }(t); const i = e(t, r) || Lg; if (!n.animation || "none" === window.getComputedStyle(t).transitionProperty) return i(), Uu(void 0); const o = new S, a = o.pipe(function (...t) { return e => mc(e, Uu(...t)) }(!0)); $g.set(t, { transition$: o, context: r }); const u = function (t) { const { transitionDelay: e, transitionDuration: n } = window.getComputedStyle(t); return 1e3 * (parseFloat(e) + parseFloat(n)) }(t), c = pg(t, "transitionend").pipe(Og(a), Ku(({ target: e }) => e === t)); return function (...t) { if (1 === t.length) { if (!l(t[0])) return t[0]; t = t[0] } return B(t, void 0).lift(new bg) }(function (t = 0, e, n) { let r = -1; return vg(e) ? r = Number(e) < 1 ? 1 : Number(e) : E(e) && (n = e), E(n) || (n = _g), new _(e => { const s = vg(t) ? t : +t - n.now(); return n.schedule(wg, s, { index: 0, period: r, subscriber: e }) }) }(u + Hg).pipe(Og(a)), c).pipe(Og(a)).subscribe(() => { $g.delete(t), i(), o.next(), o.complete() }), o.asObservable() }; let Bg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), qg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), Wg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) } }), t })(), Zg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), Gg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) } }), t })(); var Qg = function (t) { return t[t.Tab = 9] = "Tab", t[t.Enter = 13] = "Enter", t[t.Escape = 27] = "Escape", t[t.Space = 32] = "Space", t[t.PageUp = 33] = "PageUp", t[t.PageDown = 34] = "PageDown", t[t.End = 35] = "End", t[t.Home = 36] = "Home", t[t.ArrowLeft = 37] = "ArrowLeft", t[t.ArrowUp = 38] = "ArrowUp", t[t.ArrowRight = 39] = "ArrowRight", t[t.ArrowDown = 40] = "ArrowDown", t }({}); const Kg = ["a[href]", "button:not([disabled])", 'input:not([disabled]):not([type="hidden"])', "select:not([disabled])", "textarea:not([disabled])", "[contenteditable]", '[tabindex]:not([tabindex="-1"])'].join(", "); function Jg(t) { const e = Array.from(t.querySelectorAll(Kg)).filter(t => -1 !== t.tabIndex); return [e[0], e[e.length - 1]] } let Yg = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu, og]] }), t })(), Xg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = ye({ type: t, selectors: [["", 8, "navbar"]] }), t })(), tm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) } }), t })(), em = (() => { class t { constructor(t) { this.backdrop = !0, this.keyboard = !0, this.animation = t.animation } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Fg)) }, t.\u0275prov = lt({ factory: function () { return new t(Zt(Fg)) }, token: t, providedIn: "root" }), t })(); class nm { constructor(t, e, n) { this.nodes = t, this.viewRef = e, this.componentRef = n } } const rm = () => { }; let sm = (() => { class t { constructor(t) { this._document = t } compensate() { const t = this._getWidth(); return this._isPresent(t) ? this._adjustBody(t) : rm } _adjustBody(t) { const e = this._document.body, n = e.style.paddingRight, r = parseFloat(window.getComputedStyle(e)["padding-right"]); return e.style["padding-right"] = r + t + "px", () => e.style["padding-right"] = n } _isPresent(t) { const e = this._document.body.getBoundingClientRect(); return window.innerWidth - (e.left + e.right) >= t - .1 * t } _getWidth() { const t = this._document.createElement("div"); t.className = "modal-scrollbar-measure"; const e = this._document.body; e.appendChild(t); const n = t.getBoundingClientRect().width - t.clientWidth; return e.removeChild(t), n } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Il)) }, t.\u0275prov = lt({ factory: function () { return new t(Zt(Il)) }, token: t, providedIn: "root" }), t })(), im = (() => { class t { constructor(t, e) { this._el = t, this._zone = e } ngOnInit() { this._zone.onStable.asObservable().pipe(pc(1)).subscribe(() => { zg(this._el.nativeElement, ({ classList: t }) => t.add("show"), { animation: this.animation, runningTransition: "continue" }) }) } hide() { return zg(this._el.nativeElement, ({ classList: t }) => t.remove("show"), { animation: this.animation, runningTransition: "stop" }) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Uo), Di(Xa)) }, t.\u0275cmp = he({ type: t, selectors: [["ngb-modal-backdrop"]], hostAttrs: [2, "z-index", "1050"], hostVars: 6, hostBindings: function (t, e) { 2 & t && (no("modal-backdrop" + (e.backdropClass ? " " + e.backdropClass : "")), eo("show", !e.animation)("fade", e.animation)) }, inputs: { animation: "animation", backdropClass: "backdropClass" }, decls: 0, vars: 0, template: function (t, e) { }, encapsulation: 2 }), t })(); class om { close(t) { } dismiss(t) { } } class am { constructor(t, e, n, r) { this._windowCmptRef = t, this._contentRef = e, this._backdropCmptRef = n, this._beforeDismiss = r, this._closed = new S, this._dismissed = new S, this._hidden = new S, t.instance.dismissEvent.subscribe(t => { this.dismiss(t) }), this.result = new Promise((t, e) => { this._resolve = t, this._reject = e }), this.result.then(null, () => { }) } get componentInstance() { if (this._contentRef && this._contentRef.componentRef) return this._contentRef.componentRef.instance } get closed() { return this._closed.asObservable().pipe(Og(this._hidden)) } get dismissed() { return this._dismissed.asObservable().pipe(Og(this._hidden)) } get hidden() { return this._hidden.asObservable() } get shown() { return this._windowCmptRef.instance.shown.asObservable() } close(t) { this._windowCmptRef && (this._closed.next(t), this._resolve(t), this._removeModalElements()) } _dismiss(t) { this._dismissed.next(t), this._reject(t), this._removeModalElements() } dismiss(t) { if (this._windowCmptRef) if (this._beforeDismiss) { const e = this._beforeDismiss(); e && e.then ? e.then(e => { !1 !== e && this._dismiss(t) }, () => { }) : !1 !== e && this._dismiss(t) } else this._dismiss(t) } _removeModalElements() { const t = this._windowCmptRef.instance.hide(), e = this._backdropCmptRef ? this._backdropCmptRef.instance.hide() : Uu(void 0); t.subscribe(() => { const { nativeElement: t } = this._windowCmptRef.location; t.parentNode.removeChild(t), this._windowCmptRef.destroy(), this._contentRef && this._contentRef.viewRef && this._contentRef.viewRef.destroy(), this._windowCmptRef = null, this._contentRef = null }), e.subscribe(() => { if (this._backdropCmptRef) { const { nativeElement: t } = this._backdropCmptRef.location; t.parentNode.removeChild(t), this._backdropCmptRef.destroy(), this._backdropCmptRef = null } }), Sg(t, e).subscribe(() => { this._hidden.next(), this._hidden.complete() }) } } var lm = function (t) { return t[t.BACKDROP_CLICK = 0] = "BACKDROP_CLICK", t[t.ESC = 1] = "ESC", t }({}); let um = (() => { class t { constructor(t, e, n) { this._document = t, this._elRef = e, this._zone = n, this._closed$ = new S, this._elWithFocus = null, this.backdrop = !0, this.keyboard = !0, this.dismissEvent = new wa, this.shown = new S, this.hidden = new S } dismiss(t) { this.dismissEvent.emit(t) } ngOnInit() { this._elWithFocus = this._document.activeElement } ngAfterViewInit() { this._show() } ngOnDestroy() { this._disableEventHandling() } hide() { const { nativeElement: t } = this._elRef, e = { animation: this.animation, runningTransition: "stop" }, n = Sg(zg(t, () => t.classList.remove("show"), e), zg(this._dialogEl.nativeElement, () => { }, e)); return n.subscribe(() => { this.hidden.next(), this.hidden.complete() }), this._disableEventHandling(), this._restoreFocus(), n } _show() { const { nativeElement: t } = this._elRef, e = { animation: this.animation, runningTransition: "continue" }; Sg(zg(t, () => t.classList.add("show"), e), zg(this._dialogEl.nativeElement, () => { }, e)).subscribe(() => { this.shown.next(), this.shown.complete() }), this._enableEventHandling(), this._setFocus() } _enableEventHandling() { const { nativeElement: t } = this._elRef; this._zone.runOutsideAngular(() => { pg(t, "keydown").pipe(Og(this._closed$), Ku(t => t.which === Qg.Escape)).subscribe(t => { this.keyboard ? requestAnimationFrame(() => { t.defaultPrevented || this._zone.run(() => this.dismiss(lm.ESC)) }) : "static" === this.backdrop && this._bumpBackdrop() }); let e = !1; pg(this._dialogEl.nativeElement, "mousedown").pipe(Og(this._closed$), Ec(() => e = !1), cc(() => pg(t, "mouseup").pipe(Og(this._closed$), pc(1))), Ku(({ target: e }) => t === e)).subscribe(() => { e = !0 }), pg(t, "click").pipe(Og(this._closed$)).subscribe(({ target: n }) => { t === n && ("static" === this.backdrop ? this._bumpBackdrop() : !0 !== this.backdrop || e || this._zone.run(() => this.dismiss(lm.BACKDROP_CLICK))), e = !1 }) }) } _disableEventHandling() { this._closed$.next() } _setFocus() { const { nativeElement: t } = this._elRef; if (!t.contains(document.activeElement)) { const e = t.querySelector("[ngbAutofocus]"), n = Jg(t)[0]; (e || n || t).focus() } } _restoreFocus() { const t = this._document.body, e = this._elWithFocus; let n; n = e && e.focus && t.contains(e) ? e : t, this._zone.runOutsideAngular(() => { setTimeout(() => n.focus()), this._elWithFocus = null }) } _bumpBackdrop() { "static" === this.backdrop && zg(this._elRef.nativeElement, ({ classList: t }) => (t.add("modal-static"), () => t.remove("modal-static")), { animation: this.animation, runningTransition: "continue" }) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Il), Di(Uo), Di(Xa)) }, t.\u0275cmp = he({ type: t, selectors: [["ngb-modal-window"]], viewQuery: function (t, e) { var n, r, s, i, o, a; 1 & t && (i = Dg, o = !0, function (t, e, n, r, s, i) { t.firstCreatePass && (function (t, e, n) { null === t.queries && (t.queries = new Ta), t.queries.track(new Aa(e, -1)) }(t, new Ea(n, r, !0, s)), t.staticViewQueries = !0), function (t, e) { const n = new Ca; ss(t, e, n, n.destroy), null === e[19] && (e[19] = new xa), e[19].queries.push(new Sa(n)) }(t, e) }(sn(), rn(), i, o, a)), 2 & t && function (t) { const e = rn(), n = sn(), r = mn(); yn(r + 1); const s = Ia(n, r); if (t.dirty && Ke(e) === s.metadata.isStatic) { if (null === s.matches) t.reset([]); else { const i = s.crossesNgTemplate ? function t(e, n, r, s) { const i = e.queries.getByIndex(r), o = i.matches; if (null !== o) { const a = Ra(e, n, i, r); for (let e = 0; e < o.length; e += 2) { const r = o[e]; if (r > 0) s.push(a[e / 2]); else { const i = o[e + 1], a = n[-r]; for (let e = Ce; e < a.length; e++) { const n = a[e]; n[17] === n[3] && t(n[1], n, i, s) } if (null !== a[9]) { const e = a[9]; for (let n = 0; n < e.length; n++) { const r = e[n]; t(r[1], r, i, s) } } } } } return s }(n, e, r, []) : Ra(n, e, s, r); t.reset(i), t.notifyOnChanges() } return !0 } return !1 }((r = rn(), s = mn(), n = r[19].queries[s].queryList)) && (e._dialogEl = n.first) }, hostAttrs: ["role", "dialog", "tabindex", "-1"], hostVars: 7, hostBindings: function (t, e) { 2 & t && (ji("aria-modal", !0)("aria-labelledby", e.ariaLabelledBy)("aria-describedby", e.ariaDescribedBy), no("modal d-block" + (e.windowClass ? " " + e.windowClass : "")), eo("fade", e.animation)) }, inputs: { backdrop: "backdrop", keyboard: "keyboard", animation: "animation", ariaLabelledBy: "ariaLabelledBy", ariaDescribedBy: "ariaDescribedBy", centered: "centered", scrollable: "scrollable", size: "size", windowClass: "windowClass" }, outputs: { dismissEvent: "dismiss" }, ngContentSelectors: Ng, decls: 4, vars: 2, consts: [["role", "document"], ["dialog", ""], [1, "modal-content"]], template: function (t, e) { 1 & t && (function (t) { const e = rn()[16][6]; if (!e.projection) { const t = e.projection = ne(1, null), n = t.slice(); let r = e.child; for (; null !== r;) { const e = 0; null !== e && (n[e] ? n[e].projectionNext = r : t[e] = r, n[e] = r), r = r.next } } }(), Fi(0, "div", 0, 1), Fi(2, "div", 2), function (t, e = 0, n) { const r = rn(), s = sn(), i = Qr(s, t, 1, null, n || null); null === i.projection && (i.projection = e), un(), function (t, e, n) { Ws(e[11], 0, e, n, Us(t, n, e), $s(n.parent || e[6], e)) }(s, r, i) }(3), Li(), Li()), 2 & t && no("modal-dialog" + (e.size ? " modal-" + e.size : "") + (e.centered ? " modal-dialog-centered" : "") + (e.scrollable ? " modal-dialog-scrollable" : "")) }, styles: ["ngb-modal-window .component-host-scrollable{-ms-flex-direction:column;display:-ms-flexbox;display:flex;flex-direction:column;overflow:hidden}"], encapsulation: 2 }), t })(), cm = (() => { class t { constructor(t, e, n, r, s, i) { this._applicationRef = t, this._injector = e, this._document = n, this._scrollBar = r, this._rendererFactory = s, this._ngZone = i, this._activeWindowCmptHasChanged = new S, this._ariaHiddenValues = new Map, this._backdropAttributes = ["animation", "backdropClass"], this._modalRefs = [], this._windowAttributes = ["animation", "ariaLabelledBy", "ariaDescribedBy", "backdrop", "centered", "keyboard", "scrollable", "size", "windowClass"], this._windowCmpts = [], this._activeInstances = new wa, this._activeWindowCmptHasChanged.subscribe(() => { if (this._windowCmpts.length) { const t = this._windowCmpts[this._windowCmpts.length - 1]; ((t, e, n, r = !1) => { this._ngZone.runOutsideAngular(() => { const t = pg(e, "focusin").pipe(Og(n), T(t => t.target)); pg(e, "keydown").pipe(Og(n), Ku(t => t.which === Qg.Tab), Pg(t)).subscribe(([t, n]) => { const [r, s] = Jg(e); n !== r && n !== e || !t.shiftKey || (s.focus(), t.preventDefault()), n !== s || t.shiftKey || (r.focus(), t.preventDefault()) }), r && pg(e, "click").pipe(Og(n), Pg(t), T(t => t[1])).subscribe(t => t.focus()) }) })(0, t.location.nativeElement, this._activeWindowCmptHasChanged), this._revertAriaHidden(), this._setAriaHidden(t.location.nativeElement) } }) } open(t, e, n, r) { const s = r.container instanceof HTMLElement ? r.container : Ug(r.container) ? this._document.querySelector(r.container) : this._document.body, i = this._rendererFactory.createRenderer(null, null), o = this._scrollBar.compensate(), a = () => { this._modalRefs.length || (i.removeClass(this._document.body, "modal-open"), this._revertAriaHidden()) }; if (!s) throw new Error(`The specified modal container "${r.container || "body"}" was not found in the DOM.`); const l = new om, u = this._getContentRef(t, r.injector || e, n, l, r); let c = !1 !== r.backdrop ? this._attachBackdrop(t, s) : void 0, h = this._attachWindowComponent(t, s, u), d = new am(h, u, c, r.beforeDismiss); return this._registerModalRef(d), this._registerWindowCmpt(h), d.result.then(o, o), d.result.then(a, a), l.close = t => { d.close(t) }, l.dismiss = t => { d.dismiss(t) }, this._applyWindowOptions(h.instance, r), 1 === this._modalRefs.length && i.addClass(this._document.body, "modal-open"), c && c.instance && this._applyBackdropOptions(c.instance, r), d } get activeInstances() { return this._activeInstances } dismissAll(t) { this._modalRefs.forEach(e => e.dismiss(t)) } hasOpenModals() { return this._modalRefs.length > 0 } _attachBackdrop(t, e) { let n = t.resolveComponentFactory(im).create(this._injector); return this._applicationRef.attachView(n.hostView), e.appendChild(n.location.nativeElement), n } _attachWindowComponent(t, e, n) { let r = t.resolveComponentFactory(um).create(this._injector, n.nodes); return this._applicationRef.attachView(r.hostView), e.appendChild(r.location.nativeElement), r } _applyWindowOptions(t, e) { this._windowAttributes.forEach(n => { Ug(e[n]) && (t[n] = e[n]) }) } _applyBackdropOptions(t, e) { this._backdropAttributes.forEach(n => { Ug(e[n]) && (t[n] = e[n]) }) } _getContentRef(t, e, n, r, s) { return n ? n instanceof aa ? this._createFromTemplateRef(n, r) : "string" == typeof n ? this._createFromString(n) : this._createFromComponent(t, e, n, r, s) : new nm([]) } _createFromTemplateRef(t, e) { const n = t.createEmbeddedView({ $implicit: e, close(t) { e.close(t) }, dismiss(t) { e.dismiss(t) } }); return this._applicationRef.attachView(n), new nm([n.rootNodes], n) } _createFromString(t) { const e = this._document.createTextNode("" + t); return new nm([[e]]) } _createFromComponent(t, e, n, r, s) { const i = t.resolveComponentFactory(n), o = wi.create({ providers: [{ provide: om, useValue: r }], parent: e }), a = i.create(o), l = a.location.nativeElement; return s.scrollable && l.classList.add("component-host-scrollable"), this._applicationRef.attachView(a.hostView), new nm([[l]], a.hostView, a) } _setAriaHidden(t) { const e = t.parentElement; e && t !== this._document.body && (Array.from(e.children).forEach(e => { e !== t && "SCRIPT" !== e.nodeName && (this._ariaHiddenValues.set(e, e.getAttribute("aria-hidden")), e.setAttribute("aria-hidden", "true")) }), this._setAriaHidden(e)) } _revertAriaHidden() { this._ariaHiddenValues.forEach((t, e) => { t ? e.setAttribute("aria-hidden", t) : e.removeAttribute("aria-hidden") }), this._ariaHiddenValues.clear() } _registerModalRef(t) { const e = () => { const e = this._modalRefs.indexOf(t); e > -1 && (this._modalRefs.splice(e, 1), this._activeInstances.emit(this._modalRefs)) }; this._modalRefs.push(t), this._activeInstances.emit(this._modalRefs), t.result.then(e, e) } _registerWindowCmpt(t) { this._windowCmpts.push(t), this._activeWindowCmptHasChanged.next(), t.onDestroy(() => { const e = this._windowCmpts.indexOf(t); e > -1 && (this._windowCmpts.splice(e, 1), this._activeWindowCmptHasChanged.next()) }) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(_l), Zt(wi), Zt(Il), Zt(sm), Zt(Fo), Zt(Xa)) }, t.\u0275prov = lt({ factory: function () { return new t(Zt(_l), Zt(Ut), Zt(Il), Zt(sm), Zt(Fo), Zt(Xa)) }, token: t, providedIn: "root" }), t })(), hm = (() => { class t { constructor(t, e, n, r) { this._moduleCFR = t, this._injector = e, this._modalStack = n, this._config = r } open(t, e = {}) { const n = Object.assign({}, this._config, e); return this._modalStack.open(this._moduleCFR, this._injector, t, n) } get activeInstances() { return this._modalStack.activeInstances } dismissAll(t) { this._modalStack.dismissAll(t) } hasOpenModals() { return this._modalStack.hasOpenModals() } } return t.\u0275fac = function (e) { return new (e || t)(Zt(Do), Zt(wi), Zt(cm), Zt(em)) }, t.\u0275prov = lt({ factory: function () { return new t(Zt(Do), Zt(Ut), Zt(cm), Zt(em)) }, token: t, providedIn: "root" }), t })(), dm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [hm] }), t })(), pm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), fm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), gm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), mm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), ym = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), _m = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), vm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(), wm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) } }), t })(), bm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [[iu]] }), t })(); const Cm = [Bg, qg, Wg, Zg, Gg, Yg, tm, dm, pm, fm, gm, mm, ym, _m, vm, wm, bm]; let Sm = (() => { class t { } return t.\u0275mod = ge({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, imports: [Cm, Bg, qg, Wg, Zg, Gg, Yg, tm, dm, pm, fm, gm, mm, ym, _m, vm, wm, bm] }), t })(); function xm(t, e) { if (1 & t) { const t = rn(); Fi(0, "nav", 2), Fi(1, "div", 3), Fi(2, "a", 4), po(3, "Home"), Li(), Fi(4, "a", 5), Bi("click", (function () { return en.lFrame.contextLView = t, Zi().logout() })), po(5, "Logout"), Li(), Li(), Li() } } let Em = (() => { class t { constructor(t, e) { this.router = t, this.authenticationService = e, this.authenticationService.currentUser.subscribe(t => this.currentUser = t) } logout() { this.authenticationService.logout(), this.router.navigate(["/login"]) } } return t.\u0275fac = function (e) { return new (e || t)(Di(Zd), Di(lg)) }, t.\u0275cmp = he({ type: t, selectors: [["app-root"]], decls: 3, vars: 1, consts: [["class", "navbar navbar-expand navbar-dark bg-dark", 4, "ngIf"], [1, "container"], [1, "navbar", "navbar-expand", "navbar-dark", "bg-dark"], [1, "navbar-nav"], ["routerLink", "/", 1, "nav-item", "nav-link"], [1, "nav-item", "nav-link", 3, "click"]], template: function (t, e) { 1 & t && (Ni(0, xm, 6, 0, "nav", 0), Fi(1, "div", 1), Hi(2, "router-outlet"), Li()), 2 & t && Ui("ngIf", e.currentUser) }, directives: [nu, Kd, Xg, Gd], styles: [""] }), t })(), Tm = (() => { class t { constructor(t) { this.authenticationService = t } intercept(t, e) { const n = this.authenticationService.currentUserValue; return n && n.token && (t = t.clone({ setHeaders: { Authorization: "Bearer " + n.token } })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(lg)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), Am = (() => { class t { constructor(t) { this.authenticationService = t } intercept(t, e) { return e.handle(t).pipe(vc(t => { return 401 === t.status && (this.authenticationService.logout(), location.reload()), e = t.error.message || t.statusText, new _(t => t.error(e)); var e })) } } return t.\u0275fac = function (e) { return new (e || t)(Zt(lg)) }, t.\u0275prov = lt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), km = (() => { class t { } return t.\u0275mod = ge({ type: t, bootstrap: [Em] }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [{ provide: Vp, useClass: Tm, multi: !0 }, { provide: Vp, useClass: Am, multi: !0 }], imports: [[Du, dg, Sm, og, ag, Wp]] }), t })(); (function () { if (gr) throw new Error("Cannot enable prod mode after platform setup."); fr = !1 })(), ju().bootstrapModule(km).catch(t => console.error(t)) }, zn8P: function (t, e) { function n(t) { return Promise.resolve().then((function () { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })) } n.keys = function () { return [] }, n.resolve = n, t.exports = n, n.id = "zn8P" } }, [[0, 0]]]);